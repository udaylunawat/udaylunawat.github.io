<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <title>Neural Skills Brain Visualization</title> -->
    <style>
        /* Global styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(circle at 50% 50%, #0f1318 0%, #05070b 90%);
            color: #e8fff3;
            font-family: 'Montserrat', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Brain container */
        #brain-host {
            position: relative;
            width: 100%;
            height: min(88svh, 88dvh, 760px);
            aspect-ratio: 16 / 11;
            z-index: 2;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 0.4s ease-in-out;
            margin: 0 auto;
        }
        
        /* Brain links SVG layer */
        #brain-links-layer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        /* Brain link styles */
        .brain-link {
            fill: none;
            stroke: rgba(140, 255, 210, 0.75);
            stroke-width: 2.1;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 8px rgba(120, 255, 200, 0.9)) 
                    drop-shadow(0 0 22px rgba(120, 255, 200, 0.9));
            shape-rendering: geometricPrecision;
            vector-effect: non-scaling-stroke;
        }
        
        .brain-link--active {
            stroke-width: 3.0;
            stroke: rgba(190, 255, 230, 1);
            animation: brainLinkPulse 1.35s ease-in-out infinite;
        }
        
        @keyframes brainLinkPulse {
            0% {
                opacity: 0.45;
                filter: drop-shadow(0 0 6px rgba(140, 255, 210, 0.7)) 
                        drop-shadow(0 0 16px rgba(140, 255, 210, 0.8));
            }
            50% {
                opacity: 1;
                filter: drop-shadow(0 0 12px rgba(190, 255, 230, 1)) 
                        drop-shadow(0 0 32px rgba(190, 255, 230, 1));
            }
            100% {
                opacity: 0.5;
                filter: drop-shadow(0 0 6px rgba(140, 255, 210, 0.7)) 
                        drop-shadow(0 0 16px rgba(140, 255, 210, 0.8));
            }
        }
        
        /* Brain cluster cards */
        .brain-cluster {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%) scale(1);
            min-width: 220px;  /* Increased from 180px */
            max-width: 260px;  /* Increased from 220px */
            background: transparent;
            border: none;
            backdrop-filter: blur(10px) saturate(140%);
            color: rgba(252, 255, 254, 0.98);
            box-shadow: none;
            border-radius: 14px;
            padding: 16px;  /* Increased from 12px */
            pointer-events: auto;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10;
            overflow: hidden;
        }
        
        .brain-cluster--active {
            background: transparent;
        }
        
        .cluster-title {
            color: #a0ffd0;
            font-size: 18px;  /* Increased from 16px */
            font-weight: 600;
            text-align: center;
            margin-bottom: 16px;  /* Increased from 12px */
            text-shadow: 0 0 4px rgba(38,162,105,0.45);
            letter-spacing: 0.05em;
            white-space: nowrap;
        }
        
        /* Skills Carousel */
        .skills-carousel {
            position: relative;
            width: 100%;
            height: 70px;  /* Increased from 60px */
            overflow: hidden;
            border-radius: none;
            background: transparent;
        }
        
        .skills-track {
            display: flex;
            transition: transform 0.5s ease;
            height: 100%;
            align-items: center;
            padding: 0 8px;
        }
        
        .skill-item {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 6px;
            border-radius: none;
            background: transparent;
            border: none;
            transition: all 0.3s ease;
            text-align: center;
            margin: 0 4px;
            position: relative;
            min-width: 50px;
            height: 45px;
        }
        
        .skill-item:hover {
            background: transparent;
            transform: scale(1.1);
            z-index: 100;
        }
        
        .skill-icon {
            width: 45px;
            height: 45px;
            object-fit: contain;
            transition: all 0.3s ease;
        }
        
        .skill-item:hover .skill-icon {
            transform: scale(1.3);
            filter: brightness(1.2) drop-shadow(0 0 8px rgba(120, 255, 200, 0.8));
        }
        
        /* Tooltip for skill names */
        .skill-tooltip {
            position: absolute;
            bottom: -35px;  /* Adjusted for larger items */
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            color: #e8fff3;
            padding: 6px 10px;  /* Increased padding */
            border-radius: none;
            font-size: 12px;  /* Slightly larger font */
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .skill-item:hover .skill-tooltip {
            opacity: 1;
        }
        
        /* Update the hover styles for brain-cluster */
        .brain-cluster:hover {
            /* border-color: rgba(120, 255, 190, 0.85);
            box-shadow: 0 0 0 1px rgba(38,162,105,0.55),
                        0 10px 28px rgba(0, 0, 0, 0.85),
                        0 0 26px rgba(38,162,105,0.65); */
            min-width: 360px;  /* Increased from 280px/300px */
            max-width: 600px;  /* Increased from 320px */
            padding: 20px;     /* Increased padding */
        }

        /* Make skills grid larger on hover */
        .brain-cluster:hover .skills-carousel {
            height: auto;
            /* max-height: 240px;  Increased from 180px - fits 4x3 grid better */
            overflow-y: auto;
        }

        .brain-cluster:hover .skills-track {
            flex-wrap: wrap;
            justify-content: center;
            transform: none !important;
            padding: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .brain-cluster:hover .skill-item {
            margin: 0;
            min-width: auto;
            width: calc(33.333% - 8px);
            height: 65px;  /* Increased from 55px */
            padding: 8px;  /* Increased padding */
            flex: 0 0 calc(33.333% - 8px);
        }

        .brain-cluster:hover .skill-icon {
            width: 66px; /* Larger icons on hover */
            height: 66px;
        }
        
        /* Only tweak non-active cards on hover so active glow always wins */
        .brain-cluster:not(.brain-cluster--active):hover {
            /* border-color: rgba(120, 255, 190, 0.85);
            box-shadow: 0 0 0 1px rgba(38,162,105,0.55),
                        0 10px 28px rgba(0, 0, 0, 0.85),
                        0 0 26px rgba(38,162,105,0.65); */
            min-width: 240px;
            max-width: 280px;
        }
        
        /* Let CSS beat inline opacity set by JS when hovered */
        .brain-cluster:hover { opacity: 1 !important; z-index: 9999 !important; }
        
        /* Brain name overlay */
        .brain-name2d {
            pointer-events: none;
            font: 700 clamp(18px, calc(3.6vw * var(--ui-scale)), 56px)/1.1 'Montserrat', sans-serif;
            letter-spacing: .06em;
            color: #e8fff3;
            -webkit-text-stroke: .4px rgba(0,0,0,.25);
            text-shadow: 0 0 12px rgba(38,162,105,1),
                        0 0 28px rgba(38,162,105,1),
                        0 0 48px rgba(38,162,105,.9),
                        0 0 90px rgba(38,162,105,.7);
        }
        
        /* Section styling */
        .section {
            padding: 60px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section-title {
            text-align: center;
            font-size: 4.5rem;
            margin-bottom: 40px;
            color: #e8fff3;
            text-shadow: 0 0 10px rgba(38,162,105,0.7);
        }
        
        /* Mobile tweaks */
        @media (max-width: 768px) {
            #brain-host {
                height: 72svh;
            }
            
            .brain-cluster {
                min-width: 160px;
                max-width: 200px;
                background: rgba(18,24,28,.70);
                padding: 10px;
            }
            
            .brain-cluster:hover {
                min-width: 200px;
                max-width: 240px;
            }
            
            .skills-carousel {
                height: 50px;
            }
            
            .skill-item {
                min-width: 45px;
                height: 40px;
                margin: 0 3px;
            }
            
            .skill-icon {
                width: 24px;
                height: 24px;
            }
            
            .cluster-title {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <section id="skills" class="section">
        <!-- <h2 class="section-title">Neural Skills Network</h2> -->
        <div id="brain-host" class="brain-host"></div>
    </section>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/modifiers/SimplifyModifier.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <!-- Main brain visualization script -->
    <script>
        // Enhanced brainSkills.js with carousel and neuron effects
        (function() {
            'use strict';
            
            // Skill logo configuration
            const skillLogos = {
                // Programming & Core ML
                Python: ['https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=fff'],
                PySpark: ['https://img.shields.io/badge/PySpark-E25A1C?style=for-the-badge&logo=apache-spark&logoColor=white'],
                Groovy: ['https://img.shields.io/badge/Groovy-4298B8?style=for-the-badge&logo=apache-groovy&logoColor=white'],
                FastAPI: ['https://img.shields.io/badge/FastAPI-009688?style=for-the-badge&logo=fastapi&logoColor=white'],
                
                // ML Frameworks
                'Neural Nets': ['https://img.shields.io/badge/-TensorFlow-FF6F00?logo=tensorflow&logoColor=white'],
                TensorFlow: ['https://img.shields.io/badge/TensorFlow-FF6F00?style=for-the-badge&logo=tensorflow&logoColor=white'],
                ScikitLearn: ['https://img.shields.io/badge/Scikit_Learn-F7931E?style=for-the-badge&logo=scikit-learn&logoColor=white'],
                XGBoost: ['https://img.shields.io/badge/XGBoost-017CEE?style=for-the-badge&logo=xgboost&logoColor=white'],
                
                // Data & Visualization
                Pandas: ['https://img.shields.io/badge/Pandas-150458?style=for-the-badge&logo=pandas&logoColor=white'],
                NumPy: ['https://img.shields.io/badge/NumPy-013243?style=for-the-badge&logo=numpy&logoColor=white'],
                Tableau: ['https://img.shields.io/badge/Tableau-E97627?style=for-the-badge&logo=tableau&logoColor=white'],
                Matplotlib: ['https://img.shields.io/badge/Matplotlib-11557C?style=for-the-badge'],
                Folium: ['https://img.shields.io/badge/Folium-77B829?style=for-the-badge'],
                
                // LLM & AI Frameworks
                LangChain: ['https://img.shields.io/badge/LangChain-000000?style=for-the-badge'],
                LangGraph: ['https://img.shields.io/badge/LangGraph-000000?style=for-the-badge'],
                Langfuse: ['https://img.shields.io/badge/Langfuse-000000?style=for-the-badge'],
                Prompting: ['https://img.shields.io/badge/Prompting-412991?logo=openai&logoColor=white'],
                RAG: ['https://img.shields.io/badge/RAG-0b7285?logo=readthedocs&logoColor=white'],
                Embeddings: ['https://img.shields.io/badge/Embeddings-FFB000'],
                'Vector DBs': ['https://images.seeklogo.com/logo-png/48/1/pinecone-logo-png_seeklogo-482364.png'],
                
                // Web & App Frameworks
                Streamlit: ['https://img.shields.io/badge/-Streamlit-FF4B4B?style=flat&logo=streamlit&logoColor=black'],
                Gradio: ['https://img.shields.io/badge/Gradio-FF4B4B?style=for-the-badge&logo=gradio&logoColor=white'],
                Plotly: ['https://img.shields.io/badge/-Plotly-3F4F75?style=flat&logo=plotly&logoColor=white'],
                Dash: ['https://img.shields.io/badge/Dash-008DE4?style=for-the-badge&logo=dash&logoColor=white'],
                
                // MLOps & Infrastructure
                MLflow: ['https://img.shields.io/badge/MLflow-0194E2?style=for-the-badge&logo=mlflow&logoColor=white'],
                'Seldon Core': ['https://img.shields.io/badge/Seldon_Core-2F80ED?style=for-the-badge'],
                WeightsBiases: ['https://img.shields.io/badge/Weights_&_Biases-FFBE00?style=for-the-badge&logo=weightsandbiases&logoColor=black'],
                Jenkins: ['https://img.shields.io/badge/Jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white'],
                GitHubActions: ['https://img.shields.io/badge/GitHub_Actions-2088FF?style=for-the-badge&logo=github-actions&logoColor=white'],
                
                // Databases
                MongoDB: ['https://img.shields.io/badge/MongoDB-47A248?style=for-the-badge&logo=mongodb&logoColor=white'],
                Redis: ['https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white'],
                MySQL: ['https://img.shields.io/badge/MySQL-4479A1?style=for-the-badge&logo=mysql&logoColor=white'],
                PostgreSQL: ['https://img.shields.io/badge/PostgreSQL-336791?style=for-the-badge&logo=postgresql&logoColor=white'],
                SQLModel: ['https://img.shields.io/badge/SQLModel-000000?style=for-the-badge'],
                Alembic: ['https://img.shields.io/badge/Alembic-000000?style=for-the-badge'],
                
                // Cloud & Infrastructure
                Docker: ['https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white'],
                Kubernetes: ['https://img.shields.io/badge/Kubernetes-2496ED?style=for-the-badge&logo=kubernetes&logoColor=white'],
                Kubeflow: ['https://img.shields.io/badge/Kubeflow-2496ED?style=for-the-badge&logo=kubeflow&logoColor=white'],
                GCP: ['https://img.shields.io/badge/-Google%20Cloud%20Platform-4285F4?style=flat&logo=google%20cloud&logoColor=black'],
                CloudRun: ['https://img.shields.io/badge/Cloud_Run-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white'],
                VertexAI: ['https://img.shields.io/badge/Vertex_AI-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white'],
                ComputeEngine: ['https://img.shields.io/badge/Compute_Engine-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white'],
                CloudStorage: ['https://img.shields.io/badge/Cloud_Storage-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white'],
                CloudFunctions: ['https://img.shields.io/badge/Cloud_Functions-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white'],
                AWSEC2: ['https://img.shields.io/badge/EC2-FF9900?style=for-the-badge&logo=amazon-aws&logoColor=white'],
                S3: ['https://img.shields.io/badge/S3-569A31?style=for-the-badge&logo=amazon-s3&logoColor=white'],
                SageMaker: ['https://img.shields.io/badge/SageMaker-232F3E?style=for-the-badge&logo=amazon-aws&logoColor=white'],
                Lambda: ['https://img.shields.io/badge/Lambda-FF9900?style=for-the-badge&logo=aws-lambda&logoColor=white'],
                Databricks: ['https://img.shields.io/badge/Databricks-FF3621?style=for-the-badge&logo=databricks&logoColor=white'],
                
                // AI Services
                Whisper: ['https://img.shields.io/badge/Whisper-000000?logo=openai&logoColor=white'],
                Agents: ['https://img.shields.io/badge/Agents-AI-blueviolet'],
                'LLM Orchestration': ['https://img.shields.io/badge/LLM%20Orchestration-000000?logo=openai&logoColor=white'],
                Eval: ['https://img.shields.io/badge/Eval-FFB000?logo=huggingface&logoColor=white'],
                GoogleADK: ['https://img.shields.io/badge/Google_ADK-4285F4?style=for-the-badge&logo=google-cloud&logoColor=white']
            };

            // Helper to get logo URL for a skill
            function getSkillLogo(skillName) {
                const sources = skillLogos[skillName];
                if (!sources || !sources.length) {
                    return `https://via.placeholder.com/32x32/ffffff/000000?text=${encodeURIComponent(skillName)}`;
                }
                return sources[0];
            }

            // Configuration manager
            class BrainConfig {
                static getDefault() {
                    return {
                        keepRatio: 0.20,
                        accent: 0x26a269,
                        baseOpacity: 0.035,
                        fresnelPow: 2.1,
                        edgeStrength: 0.10,
                        showSurface: true,
                        showEdges: true,
                        rotSpeed: 0.0009,
                        pause: false,
                        labelBaseScale: 1.0,
                        hoverScale: 1.10,
                        particles: {
                            enabled: true,
                            count: 400, // Increased for more neural activity
                            baseSize: 0.02,
                            pulseAmp: 0.25,
                            opacity: 0.8,
                            linksPerNode: 3,
                            linkDist: 3.0,
                            rewireMs: 2000,
                            firingRate: 0.02, // Chance for neurons to fire
                            firingDuration: 0.5 // Duration of firing state
                        },
                        name: {
                            text: '',
                            offset: { x: 0, y: -0.9, z: 0 },
                            visible: true
                        },
                        mobile: {
                            particlesCount: 200,
                            labelScale: 1.25
                        },
                        carousel: {
                            speed: 0.5, // pixels per frame
                            pauseOnHover: true
                        }
                    };
                }

                static merge(defaultConfig, userConfig) {
                    return {
                        ...defaultConfig,
                        ...userConfig,
                        particles: { ...defaultConfig.particles, ...(userConfig.particles || {}) },
                        name: { ...defaultConfig.name, ...(userConfig.name || {}) },
                        mobile: { ...defaultConfig.mobile, ...(userConfig.mobile || {}) },
                        carousel: { ...defaultConfig.carousel, ...(userConfig.carousel || {}) }
                    };
                }
            }

            // Enhanced brain visualization with neuron effects
            class BrainVisualization {
                constructor(container, glbPath, clusters, options = {}) {
                    this.container = container;
                    this.glbPath = glbPath;
                    this.clusters = clusters;
                    this.cfg = BrainConfig.merge(BrainConfig.getDefault(), options);
                    this.THREE = window.THREE;
                    
                    // Carousel state
                    this.carousels = new Map();
                    this.carouselAnimations = new Map();
                    
                    this.init();
                }

                init() {
                    if (!this.THREE?.GLTFLoader) {
                        throw new Error('THREE.GLTFLoader missing');
                    }

                    this.setupRenderer();
                    this.setupScene();
                    this.setupEventListeners();
                    this.loadBrainModel();
                }

                setupRenderer() {
                    // Canvas renderer
                    this.canvas = document.createElement('canvas');
                    this.canvas.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;display:block;pointer-events:auto;';
                    this.container.style.position = 'relative';
                    this.container.appendChild(this.canvas);

                    this.renderer = new this.THREE.WebGLRenderer({ 
                        canvas: this.canvas, 
                        antialias: true, 
                        alpha: true,
                        powerPreference: "high-performance"
                    });
                    this.renderer.setClearColor(0x000000, 0);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight, false);

                    // SVG overlay for links
                    this.setupSVGLayer();

                    // CSS2D renderer for labels
                    this.setupLabelRenderer();
                }

                setupSVGLayer() {
                    const svgNS = 'http://www.w3.org/2000/svg';
                    this.linkSvg = document.createElementNS(svgNS, 'svg');
                    this.linkSvg.setAttribute('id', 'brain-links-layer');
                    this.linkSvg.setAttribute('width', '100%');
                    this.linkSvg.setAttribute('height', '100%');
                    this.linkSvg.style.position = 'absolute';
                    this.linkSvg.style.inset = '0';
                    this.linkSvg.style.pointerEvents = 'none';
                    this.container.appendChild(this.linkSvg);
                }

                setupLabelRenderer() {
                    if (this.THREE.CSS2DRenderer) {
                        this.labelRenderer = new this.THREE.CSS2DRenderer();
                        this.labelRenderer.setSize(this.container.clientWidth, this.container.clientHeight);
                        this.labelRenderer.domElement.style.position = 'absolute';
                        this.labelRenderer.domElement.style.inset = '0';
                        this.labelRenderer.domElement.style.pointerEvents = 'none';
                        this.labelRenderer.domElement.style.zIndex = '2';
                        this.container.appendChild(this.labelRenderer.domElement);
                    }
                }

                setupScene() {
                    this.scene = new this.THREE.Scene();
                    this.camera = new this.THREE.PerspectiveCamera(60, this.container.clientWidth / this.container.clientHeight, 0.1, 2000);
                    this.camera.position.set(0, 0, 4);

                    this.rig = new this.THREE.Group();
                    this.scene.add(this.rig);

                    // Enhanced lighting
                    this.scene.add(new this.THREE.AmbientLight(0xa0ffd0, 0.25));
                    const dirLight = new this.THREE.DirectionalLight(0xffffff, 0.35);
                    dirLight.position.set(5, 10, 7);
                    this.scene.add(dirLight);

                    // Add point lights for neural effects
                    this.neuralLights = [];
                    for (let i = 0; i < 5; i++) {
                        const light = new this.THREE.PointLight(0x80ffc0, 0.3, 10);
                        light.position.set(
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8,
                            (Math.random() - 0.5) * 8
                        );
                        this.scene.add(light);
                        this.neuralLights.push(light);
                    }

                    // State
                    this.anchors = {};
                    this.cards = [];
                    this.dragging = false;
                    this.prevX = 0;
                    this.rotY = 0;
                    this.targetRotY = 0;
                    this.rafId = null;

                    // Neural firing state
                    this.neuralFiring = new Map();
                    this.lastNeuralUpdate = 0;

                    // Mobile detection
                    this.isMobile = window.matchMedia('(max-width: 768px)').matches;
                    this.mq = window.matchMedia('(max-width: 768px)');
                    this.mq.addEventListener('change', e => {
                        this.isMobile = e.matches;
                        this.tuneForViewport();
                    });
                }

                setupEventListeners() {
                    // Mouse controls
                    this.canvas.addEventListener('mousedown', e => {
                        this.dragging = true;
                        this.prevX = e.clientX;
                    });

                    window.addEventListener('mousemove', e => {
                        if (!this.dragging) return;
                        this.targetRotY += (e.clientX - this.prevX) * 0.003;
                        this.prevX = e.clientX;
                    });

                    window.addEventListener('mouseup', () => this.dragging = false);

                    // Touch controls
                    this.setupTouchControls();
                }

                setupTouchControls() {
                    let touchDragging = false;
                    let lastTouchX = 0;

                    this.canvas.addEventListener('touchstart', e => {
                        e.preventDefault();
                        if (e.touches.length === 1) {
                            touchDragging = true;
                            lastTouchX = e.touches[0].clientX;
                        }
                    }, { passive: false });

                    this.canvas.addEventListener('touchmove', e => {
                        e.preventDefault();
                        if (e.touches.length === 1 && touchDragging) {
                            const touch = e.touches[0];
                            const deltaX = touch.clientX - lastTouchX;
                            this.targetRotY += deltaX * 0.003;
                            lastTouchX = touch.clientX;
                        }
                    }, { passive: false });

                    this.canvas.addEventListener('touchend', () => {
                        touchDragging = false;
                    }, { passive: false });
                }

                loadBrainModel() {
                    const loader = new this.THREE.GLTFLoader();
                    loader.load(this.glbPath, (gltf) => {
                        this.onBrainLoaded(gltf);
                    });
                }

                onBrainLoaded(gltf) {
                    this.root = gltf.scene;
                    this.mesh = this.findFirstMesh(this.root);
                    
                    if (!this.mesh) {
                        throw new Error('No mesh found in GLB');
                    }

                    this.processBrainGeometry();
                    this.setupAnchors();
                    this.buildClusterCards();
                    this.setupEnhancedParticles();
                    this.tuneForViewport();
                    this.startAnimation();
                }

                findFirstMesh(object) {
                    let mesh = null;
                    object.traverse(child => {
                        if (child.isMesh && !mesh) {
                            mesh = child;
                        }
                    });
                    return mesh;
                }

                processBrainGeometry() {
                    const originalGeom = this.THREE.BufferGeometryUtils.mergeVertices(this.mesh.geometry.toNonIndexed());
                    this.mesh.geometry = originalGeom.clone();

                    // Simplify geometry for performance
                    const modifier = new this.THREE.SimplifyModifier();
                    let geom = this.THREE.BufferGeometryUtils.mergeVertices(this.mesh.geometry.toNonIndexed());
                    const triCount = geom.attributes.position.count / 3;
                    const target = Math.max(48, Math.floor(triCount * this.cfg.keepRatio));
                    geom = modifier.modify(geom, target);
                    geom.computeVertexNormals();
                    this.mesh.geometry = geom;

                    // Apply materials
                    this.applyMaterials();
                    this.rig.add(this.root);
                }

                applyMaterials() {
                    const accent = new this.THREE.Color(this.cfg.accent);
                    
                    // Enhanced holo material with neural pulses
                    this.holoMat = new this.THREE.ShaderMaterial({
                        uniforms: { 
                            uTime: { value: 0 }, 
                            uColor: { value: accent }, 
                            uFresnelPow: { value: this.cfg.fresnelPow }, 
                            uBaseOpacity: { value: this.cfg.baseOpacity },
                            uNeuralPulse: { value: 0.0 }
                        },
                        vertexShader: `
                            varying vec3 vW; 
                            varying vec3 vN;
                            varying vec2 vUv;
                            void main(){ 
                                vN = normalize(normalMatrix * normal); 
                                vec4 wp = modelMatrix * vec4(position, 1.0); 
                                vW = wp.xyz;
                                vUv = uv;
                                gl_Position = projectionMatrix * viewMatrix * wp;
                            }`,
                        fragmentShader: `
                            precision mediump float; 
                            uniform float uTime; 
                            uniform vec3 uColor; 
                            uniform float uFresnelPow; 
                            uniform float uBaseOpacity;
                            uniform float uNeuralPulse;
                            varying vec3 vW; 
                            varying vec3 vN;
                            varying vec2 vUv;
                            
                            void main(){
                                vec3 V = normalize(cameraPosition - vW);
                                float fres = pow(1.0 - max(dot(normalize(vN), V), 0.0), uFresnelPow);
                                
                                // Neural pulse effect
                                float pulseWave = sin(uTime * 3.0 + vW.x * 2.0 + vW.y * 3.0) * 0.5 + 0.5;
                                float neuralGlow = uNeuralPulse * pulseWave * 0.3;
                                
                                // Brain activity patterns
                                float scan = 0.5 + 0.5 * sin(vW.y * 0.30 + uTime * 1.2);
                                float grid = step(0.48, fract(vW.y * 0.05 + uTime * 0.10)) * 0.12;
                                
                                float a = clamp(uBaseOpacity + fres * 0.18 + grid + neuralGlow, 0.0, 0.4);
                                vec3 col = uColor * (0.30 + mix(scan, 1.0, fres) * 0.45 + neuralGlow);
                                
                                gl_FragColor = vec4(col, a);
                            }`,
                        transparent: true, 
                        depthWrite: false, 
                        blending: this.THREE.AdditiveBlending
                    });

                    this.mesh.material = this.holoMat;

                    // Enhanced wireframe with neural impulses
                    this.wireMat = new this.THREE.ShaderMaterial({
                        uniforms: { 
                            uTime: { value: 0 }, 
                            uColor: { value: accent }, 
                            uEdge: { value: this.cfg.edgeStrength },
                            uNeuralPulse: { value: 0.0 }
                        },
                        vertexShader: `
                            varying vec3 vW; 
                            varying float vNeural;
                            void main(){ 
                                vec4 wp = modelMatrix * vec4(position, 1.0); 
                                vW = wp.xyz; 
                                
                                // Neural impulse along wires
                                vNeural = sin(uTime * 4.0 + position.y * 5.0) * 0.5 + 0.5;
                                
                                gl_Position = projectionMatrix * viewMatrix * wp; 
                            }`,
                        fragmentShader: `
                            precision mediump float; 
                            uniform float uTime; 
                            uniform vec3 uColor; 
                            uniform float uEdge; 
                            uniform float uNeuralPulse;
                            varying vec3 vW;
                            varying float vNeural;
                            
                            void main(){ 
                                float baseWave = 0.5 + 0.5 * sin(uTime * 0.9 + vW.y * 1.0);
                                float neuralImpulse = vNeural * uNeuralPulse * 0.8;
                                
                                vec3 col = uColor * (0.40 + 0.36 * baseWave + neuralImpulse);
                                float a = clamp(uEdge * (0.5 + 0.8 * baseWave) + neuralImpulse * 0.5, 0., 1.); 
                                gl_FragColor = vec4(col, a); 
                            }`,
                        transparent: true, 
                        depthWrite: false, 
                        blending: this.THREE.AdditiveBlending
                    });

                    this.wire = new this.THREE.LineSegments(
                        new this.THREE.WireframeGeometry(this.mesh.geometry), 
                        this.wireMat
                    );
                    this.mesh.add(this.wire);

                    this.animatedMats = [this.holoMat, this.wireMat];
                }

                setupEnhancedParticles() {
                    if (this.particles) {
                        this.mesh.remove(this.particles);
                        this.particles.geometry.dispose();
                        this.particles.material.dispose();
                    }

                    const particleCount = this.isMobile ? this.cfg.mobile.particlesCount : this.cfg.particles.count;
                    const positions = new Float32Array(particleCount * 3);
                    const sizes = new Float32Array(particleCount);
                    const phases = new Float32Array(particleCount);
                    const firingStates = new Float32Array(particleCount); // 0 = resting, 1 = firing

                    // Get brain surface points
                    const geometry = this.mesh.geometry;
                    const positionAttribute = geometry.attributes.position;
                    const vertexCount = positionAttribute.count;

                    for (let i = 0; i < particleCount; i++) {
                        const vertexIndex = Math.floor(Math.random() * vertexCount);
                        positions[i * 3] = positionAttribute.array[vertexIndex * 3];
                        positions[i * 3 + 1] = positionAttribute.array[vertexIndex * 3 + 1];
                        positions[i * 3 + 2] = positionAttribute.array[vertexIndex * 3 + 2];
                        
                        sizes[i] = 0.6 + Math.random() * 0.8;
                        phases[i] = Math.random() * Math.PI * 2;
                        firingStates[i] = 0; // Start in resting state
                    }

                    const geometry2 = new this.THREE.BufferGeometry();
                    geometry2.setAttribute('position', new this.THREE.BufferAttribute(positions, 3));
                    geometry2.setAttribute('aSize', new this.THREE.BufferAttribute(sizes, 1));
                    geometry2.setAttribute('aPhase', new this.THREE.BufferAttribute(phases, 1));
                    geometry2.setAttribute('aFiringState', new this.THREE.BufferAttribute(firingStates, 1));

                    // Enhanced neuron particle material
                    // Updated neuron particle material with smaller size and blue/green colors
                    const particleMaterial = new this.THREE.ShaderMaterial({
                        uniforms: {
                            uTime: { value: 0 },
                            uBaseSize: { value: this.cfg.particles.baseSize * 0.5 }, // Reduced base size
                            uPulseAmp: { value: this.cfg.particles.pulseAmp * 0.3 }, // Reduced pulse amplitude
                            uOpacity: { value: this.cfg.particles.opacity },
                            uFiringRate: { value: this.cfg.particles.firingRate }
                        },
                        vertexShader: `
                            uniform float uTime;
                            uniform float uBaseSize;
                            uniform float uPulseAmp;
                            uniform float uOpacity;
                            uniform float uFiringRate;
                            
                            attribute float aSize;
                            attribute float aPhase;
                            attribute float aFiringState;
                            
                            varying float vFiringState;
                            varying float vAlpha;
                            
                            void main() {
                                vec3 p = position;
                                
                                // Neural firing behavior - reduced effect
                                float firingIntensity = aFiringState;
                                float neuralPulse = 0.5 + 0.5 * sin(uTime * 2.0 + aPhase + position.y * 3.0);
                                
                                // Reduced firing effect
                                if (firingIntensity > 0.0) {
                                    neuralPulse = 0.8 + 0.2 * firingIntensity; // Smaller pulse
                                    p += normal * firingIntensity * 0.05; // Reduced movement
                                }
                                
                                // Subtle neuron movement
                                float drift = 0.01 * sin(uTime * 0.3 + aPhase * 2.0); // Reduced drift
                                p += normal * drift;
                                
                                vec4 mv = modelViewMatrix * vec4(p, 1.0);
                                // Reduced size multiplier during firing
                                float size = (uBaseSize + uPulseAmp * neuralPulse) * aSize * (1.0 + firingIntensity * 0.8);
                                gl_PointSize = size * (250.0 / -mv.z); // Reduced overall size
                                vAlpha = uOpacity * (0.5 + 0.5 * neuralPulse) * (1.0 + firingIntensity * 0.5);
                                vFiringState = firingIntensity;
                                gl_Position = projectionMatrix * mv;
                            }`,
                        fragmentShader: `
                            precision mediump float;
                            varying float vFiringState;
                            varying float vAlpha;
                            
                            void main() {
                                vec2 coord = gl_PointCoord - vec2(0.5);
                                float dist = length(coord);
                                
                                // Light neon blue/green colors - removed yellow
                                vec3 restingColor = vec3(0.3, 0.8, 0.9);    // Cyan-blue
                                vec3 firingColor = vec3(0.4, 1.0, 0.8);     // Light neon green
                                
                                vec3 color = mix(restingColor, firingColor, vFiringState);
                                
                                // Reduced glow effects
                                float core = smoothstep(0.4, 0.0, dist) * 0.8;     // Reduced core
                                float halo = smoothstep(0.6, 0.3, dist) * 0.4;     // Reduced halo
                                
                                // Reduced firing glow
                                float firingGlow = vFiringState * smoothstep(0.8, 0.0, dist) * 1.0;
                                
                                float a = (core + halo + firingGlow) * vAlpha;
                                
                                // Prevent rendering invisible particles
                                if (a < 0.01) discard;
                                
                                gl_FragColor = vec4(color, a);
                            }`,
                        transparent: true,
                        depthWrite: false,
                        blending: this.THREE.AdditiveBlending
                    });

                    this.particles = new this.THREE.Points(geometry2, particleMaterial);
                    this.particles.visible = this.cfg.particles.enabled;
                    this.mesh.add(this.particles);

                    // Store reference for updates
                    this.particleGeometry = geometry2;
                    this.particleMaterial = particleMaterial;
                }

                updateNeuralActivity(time) {
                    if (!this.particleGeometry) return;

                    const firingStates = this.particleGeometry.attributes.aFiringState;
                    const positions = this.particleGeometry.attributes.position;
                    const particleCount = firingStates.count;

                    // Update firing states
                    for (let i = 0; i < particleCount; i++) {
                        let currentState = firingStates.array[i];
                        
                        // Random neural firing
                        if (currentState <= 0 && Math.random() < this.cfg.particles.firingRate) {
                            currentState = 1.0; // Start firing
                        } else if (currentState > 0) {
                            // Decay firing state
                            currentState -= (1.0 / this.cfg.particles.firingDuration) * 0.016;
                            if (currentState < 0) currentState = 0;
                        }
                        
                        firingStates.array[i] = currentState;
                    }

                    firingStates.needsUpdate = true;

                    // Update neural pulse uniform for materials
                    const pulseIntensity = 0.5 + 0.5 * Math.sin(time * 2.0);
                    if (this.holoMat) this.holoMat.uniforms.uNeuralPulse.value = pulseIntensity;
                    if (this.wireMat) this.wireMat.uniforms.uNeuralPulse.value = pulseIntensity;
                }

                setupAnchors() {
                    const box = new this.THREE.Box3().setFromObject(this.root);
                    const size = new this.THREE.Vector3();
                    box.getSize(size);
                    const center = new this.THREE.Vector3();
                    box.getCenter(center);
                    this.root.position.sub(center);

                    const extX = size.x / 2, extY = size.y / 2, extZ = size.z / 2;
                    const anchorVecs = {
                        frontal:    new this.THREE.Vector3(0, 0.10 * extY, 0.62 * extZ),
                        visual:     new this.THREE.Vector3(0, 0.10 * extY, -0.62 * extZ),
                        motor:      new this.THREE.Vector3(0, 0.65 * extY, 0),
                        temporalL:  new this.THREE.Vector3(-0.68 * extX, 0.00, 0.12 * extZ),
                        temporalR:  new this.THREE.Vector3(0.68 * extX, 0.00, 0.12 * extZ),
                        infra:      new this.THREE.Vector3(0, -0.62 * extY, -0.20 * extZ),
                    };

                    Object.entries(anchorVecs).forEach(([key, position]) => {
                        const node = new this.THREE.Object3D();
                        node.position.copy(position);
                        this.mesh.add(node);
                        this.anchors[key] = { node };
                    });
                }

                buildClusterCards() {
                    this.cards.forEach(card => card.el.remove());
                    this.cards = [];
                    this.carousels.clear();
                    this.carouselAnimations.clear();

                    this.clusters.forEach((cluster, clusterIndex) => {
                        const el = document.createElement('div');
                        el.className = 'brain-cluster';
                        el.setAttribute('data-cluster-index', clusterIndex);

                        const skillsHTML = cluster.items.map(item => `
                            <div class="skill-item">
                                <img src="${getSkillLogo(item.label)}" alt="${item.label}" class="skill-icon">
                                <div class="skill-tooltip">${item.label}</div>
                            </div>
                        `).join('');

                        el.innerHTML = `
                            <h4 class="cluster-title">${cluster.title || cluster.key}</h4>
                            <div class="skills-carousel">
                                <div class="skills-track">${skillsHTML}</div>
                            </div>
                        `;

                        this.container.appendChild(el);

                        // Create link line
                        const linkEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        linkEl.setAttribute('class', 'brain-link');
                        linkEl.setAttribute('x1', '0');
                        linkEl.setAttribute('y1', '0');
                        linkEl.setAttribute('x2', '0');
                        linkEl.setAttribute('y2', '0');
                        this.linkSvg.appendChild(linkEl);

                        // Setup carousel
                        const track = el.querySelector('.skills-track');
                        const carouselData = {
                            track,
                            items: cluster.items,
                            position: 0,
                            paused: false,
                            direction: 1
                        };
                        this.carousels.set(el, carouselData);

                        this.cards.push({ 
                            key: cluster.key, 
                            el, 
                            link: linkEl,
                            clusterIndex 
                        });

                        // Add hover events for carousel pausing
                        el.addEventListener('mouseenter', () => {
                            carouselData.paused = true;
                        });
                        el.addEventListener('mouseleave', () => {
                            carouselData.paused = false;
                        });
                    });

                    this.startCarousels();
                }

                startCarousels() {
                    this.carousels.forEach((carousel, el) => {
                        const animateCarousel = () => {
                            if (!carousel.paused && this.cfg.carousel.enabled !== false) {
                                const track = carousel.track;
                                const totalWidth = track.scrollWidth;
                                const visibleWidth = track.parentElement.clientWidth;
                                
                                if (totalWidth > visibleWidth) {
                                    carousel.position -= this.cfg.carousel.speed;
                                    
                                    // Reset position when scrolled completely
                                    if (Math.abs(carousel.position) >= totalWidth - visibleWidth) {
                                        carousel.position = 0;
                                    }
                                    
                                    track.style.transform = `translateX(${carousel.position}px)`;
                                }
                            }
                            requestAnimationFrame(animateCarousel);
                        };
                        animateCarousel();
                    });
                }

                computeUiScale() {
                    const w = this.container.clientWidth || 360;
                    const s = 0.90 + Math.min(1, Math.max(0, (w - 320) / (768 - 320))) * 0.20;
                    return s;
                }

                tuneForViewport() {
                    const ui = this.computeUiScale();
                    this.container.style.setProperty('--ui-scale', ui.toFixed(3));
                    
                    if (this.isMobile) {
                        this.cfg.labelBaseScale = this.cfg.mobile.labelScale;
                        if (this.cfg.particles) {
                            this.cfg.particles.count = this.cfg.mobile.particlesCount;
                        }
                    } else {
                        this.cfg.labelBaseScale = 1.0;
                    }

                    this.resize();
                    this.fitBrain(this.isMobile ? 0.88 : 0.82);
                    
                    // Recreate particles for new count
                    if (this.mesh) {
                        this.setupEnhancedParticles();
                    }
                }

                resize() {
                    const rect = this.container.getBoundingClientRect();
                    const w = Math.max(1, Math.floor(rect.width));
                    const h = Math.max(1, Math.floor(rect.height));

                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    this.renderer.setPixelRatio(dpr);
                    this.renderer.setSize(w, h, false);

                    this.camera.aspect = w / h;
                    this.camera.updateProjectionMatrix();
                    
                    if (this.labelRenderer) {
                        this.labelRenderer.setSize(w, h);
                    }
                }

                fitBrain(fill = 0.85) {
                    if (!this.root) return;
                    this.rig.scale.setScalar(1);
                    const fov = this.THREE.Math.degToRad(this.camera.fov);
                    const viewH = 2 * Math.tan(fov / 2) * this.camera.position.z;
                    const viewW = viewH * this.camera.aspect;
                    const box = new this.THREE.Box3().setFromObject(this.root);
                    const size = new this.THREE.Vector3();
                    box.getSize(size);
                    const sx = (viewW * fill) / (size.x || 1);
                    const sy = (viewH * fill) / (size.y || 1);
                    const s = Math.min(sx, sy);
                    this.rig.scale.setScalar(s);
                }

                startAnimation() {
                    this.animate();
                }

                animate() {
                    this.rafId = requestAnimationFrame(() => this.animate());
                    if (!this.root) return;

                    const time = performance.now() * 0.001;

                    // Rotation
                    if (!this.cfg.pause && !this.dragging) {
                        this.targetRotY += this.cfg.rotSpeed;
                    }
                    this.rotY += (this.targetRotY - this.rotY) * 0.08;
                    this.rig.rotation.y = this.rotY;

                    // Update materials
                    this.animatedMats.forEach(m => m.uniforms.uTime.value = time);

                    // Update neural activity
                    this.updateNeuralActivity(time);

                    // Animate neural lights
                    this.neuralLights.forEach((light, i) => {
                        light.intensity = 0.2 + 0.1 * Math.sin(time * 2 + i);
                        light.position.x += Math.sin(time * 0.5 + i) * 0.01;
                        light.position.y += Math.cos(time * 0.7 + i) * 0.01;
                    });

                    // Update cluster cards
                    this.updateClusterCards();

                    this.renderer.render(this.scene, this.camera);
                    if (this.labelRenderer) {
                        this.labelRenderer.render(this.scene, this.camera);
                    }
                }

                updateClusterCards() {
                    const rect = this.container.getBoundingClientRect();
                    const cx = rect.width * 0.5;
                    const cy = rect.height * 0.5;
                    const ui = parseFloat(getComputedStyle(this.container).getPropertyValue('--ui-scale')) || 1;

                    // Find active card (closest to camera)
                    const cardState = this.cards.map(card => {
                        const anchor = this.anchors[card.key];
                        if (!anchor) return null;

                        const screenPos = this.projectToScreen(anchor.node);
                        const depth = 1 - Math.min(1, Math.max(0, screenPos.z));
                        const dx = screenPos.x - cx;
                        const dy = screenPos.y - cy;
                        const len = Math.hypot(dx, dy) || 1;

                        return { card, screenPos, depth, dx, dy, len };
                    }).filter(Boolean);

                    let activeCard = null;
                    if (cardState.length) {
                        activeCard = cardState.reduce((best, cur) =>
                            !best || cur.depth > best.depth ? cur : best, null
                        );
                    }

                    // Position cards
                    cardState.forEach(state => {
                        const { card, screenPos, depth, dx, dy, len } = state;
                        const push = 80 * ui;
                        const cardX = screenPos.x + (dx / len) * push;
                        const cardY = screenPos.y + (dy / len) * push;

                        let baseScale = this.cfg.labelBaseScale * (0.8 + depth * 0.4);
                        let finalScale = baseScale * ui;
                        let opacity = (screenPos.z < 1.0) ? (0.6 + depth * 0.4) : 0.4;

                        const isActive = activeCard && activeCard.card === card && depth > 0.25;

                        if (isActive) {
                            card.el.classList.add('brain-cluster--active');
                            finalScale *= 1.15;
                            opacity = Math.max(opacity, 0.9);
                        } else {
                            card.el.classList.remove('brain-cluster--active');
                        }

                        card.el.style.transform = `translate(${cardX}px, ${cardY}px) translate(-50%,-50%) scale(${finalScale})`;
                        card.el.style.opacity = opacity.toFixed(3);
                        card.el.style.zIndex = String(500 + Math.round(depth * 500));

                        // Update link
                        if (card.link) {
                            const innerX = screenPos.x + (dx / len) * 10;
                            const innerY = screenPos.y + (dy / len) * 10;

                            card.link.setAttribute('x1', innerX.toFixed(1));
                            card.link.setAttribute('y1', innerY.toFixed(1));
                            card.link.setAttribute('x2', cardX.toFixed(1));
                            card.link.setAttribute('y2', cardY.toFixed(1));

                            const linkOpacity = isActive ? 0.8 : (0.3 + depth * 0.3);
                            card.link.style.opacity = linkOpacity.toFixed(3);

                            if (isActive) {
                                card.link.classList.add('brain-link--active');
                            } else {
                                card.link.classList.remove('brain-link--active');
                            }
                        }
                    });
                }

                projectToScreen(obj3D) {
                    const v = new this.THREE.Vector3().copy(obj3D.position);
                    obj3D.parent.localToWorld(v);
                    v.project(this.camera);
                    return {
                        x: (v.x + 1) * 0.5 * this.container.clientWidth,
                        y: (1 - v.y) * 0.5 * this.container.clientHeight,
                        z: v.z
                    };
                }

                // Public API
                setOptions(newOptions) {
                    this.cfg = BrainConfig.merge(this.cfg, newOptions);
                    this.tuneForViewport();
                }

                destroy() {
                    cancelAnimationFrame(this.rafId);
                    this.renderer.dispose();
                    if (this.labelRenderer) {
                        this.labelRenderer.dispose();
                        this.labelRenderer.domElement.remove();
                    }
                    this.canvas.remove();
                    this.cards.forEach(card => card.el.remove());
                }
            }

            // Make the class available globally
            window.BrainVisualization = BrainVisualization;
            
            // Legacy mount function for backward compatibility
            window.mountBrainSkills = function(options) {
                return new BrainVisualization(
                    options.container,
                    options.glbPath,
                    options.clusters,
                    options.options
                );
            };
        })();
    </script>

    <!-- Initialize the brain visualization -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const host = document.getElementById('brain-host');
            
            // Define clusters with skills (including new ones)
            const clusters = [
                { 
                    key: 'frontal',   
                    title: 'Reasoning  Planning', 
                    items: [
                        {label: 'Python'}, 
                        {label: 'PySpark'},
                        {label: 'Groovy'},
                        {label: 'FastAPI'},
                        {label: 'LangGraph'}, 
                        {label: 'Neural Nets'}, 
                        {label: 'LangChain'},
                        {label: 'Langfuse'},
                        {label: 'SQLModel'},
                        {label: 'Alembic'}
                    ]
                },
                { 
                    key: 'visual',    
                    title: 'Visual Cortex',        
                    items: [
                        {label: 'Streamlit'}, 
                        {label: 'Gradio'}, 
                        {label: 'Plotly'}, 
                        {label: 'Dash'},
                        {label: 'Tableau'},
                        {label: 'Matplotlib'},
                        {label: 'Folium'}
                    ]
                },
                { 
                    key: 'motor',     
                    title: 'Motor  Control',      
                    items: [
                        {label: 'Agents'}, 
                        {label: 'LLM Orchestration'}, 
                        {label: 'Eval'}, 
                        {label: 'MLflow'}, 
                        {label: 'Seldon Core'},
                        {label: 'Jenkins'},
                        {label: 'GitHubActions'},
                        {label: 'WeightsBiases'}
                    ]
                },
                { 
                    key: 'temporalR', 
                    title: 'Temporal  R',         
                    items: [
                        {label: 'Whisper'},
                        {label: 'MongoDB'},
                        {label: 'Redis'}
                    ]
                },
                { 
                    key: 'temporalL', 
                    title: 'Temporal  L',         
                    items: [
                        {label: 'RAG'}, 
                        {label: 'Embeddings'}, 
                        {label: 'Vector DBs'},
                        {label: 'MySQL'},
                        {label: 'PostgreSQL'}
                    ]
                },
                { 
                    key: 'infra',     
                    title: 'Infrastructure',       
                    items: [
                        {label: 'Docker'}, 
                        {label: 'Kubernetes'},
                        {label: 'Kubeflow'},
                        {label: 'GCP'},
                        {label: 'CloudRun'},
                        {label: 'VertexAI'},
                        {label: 'ComputeEngine'},
                        {label: 'CloudStorage'},
                        {label: 'CloudFunctions'},
                        {label: 'AWSEC2'},
                        {label: 'S3'},
                        {label: 'SageMaker'},
                        {label: 'Lambda'},
                        {label: 'Databricks'},
                        {label: 'GoogleADK'}
                    ]
                }
            ];

            // Initialize the brain visualization
            const brain = new BrainVisualization(
                host,
                './brain.glb', // Make sure this file is available
                clusters,
                {
                    baseOpacity: 0.03,
                    edgeStrength: 0.10,
                    hoverScale: 1.12,
                    labelBaseScale: 1.05,
                    particles: {
                        enabled: true,
                        count: 1000,
                        baseSize: 0.02,        // Reduced from 0.08
                        pulseAmp: 0.10,        // Reduced from 0.25
                        opacity: 0.9,
                        linksPerNode: 8,
                        linkDist: 6.0,
                        rewireMs: 2000,
                        firingRate: 0.015,     // Slightly reduced firing rate
                        firingDuration: 0.4    // Reduced firing duration
                    },
                    carousel: {
                        speed: 0.5,
                        pauseOnHover: true
                    },
                    mobile: {
                        particlesCount: 200,
                        labelScale: 1.25
                    }
                }
            );

            // Handle window resize
            window.addEventListener('resize', () => {
                brain.resize();
                brain.fitBrain(window.matchMedia('(max-width: 768px)').matches ? 0.88 : 0.82);
            });
        });
    </script>
</body>
</html>