<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Skills Brain Visualization</title>
    <style>
        /* Global styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(circle at 50% 50%, #0f1318 0%, #05070b 90%);
            color: #e8fff3;
            font-family: 'Montserrat', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Brain container */
        #brain-host {
            position: relative;
            width: 100%;
            height: min(88svh, 88dvh, 760px);
            aspect-ratio: 16 / 11;
            z-index: 2;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 0.4s ease-in-out;
            margin: 0 auto;
        }
        
        /* Brain links SVG layer */
        #brain-links-layer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        /* Brain link styles */
        .brain-link {
            fill: none;
            stroke: rgba(140, 255, 210, 0.75);
            stroke-width: 2.1;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 8px rgba(120, 255, 200, 0.9)) 
                    drop-shadow(0 0 22px rgba(120, 255, 200, 0.9));
            shape-rendering: geometricPrecision;
            vector-effect: non-scaling-stroke;
        }
        
        .brain-link--active {
            stroke-width: 3.0;
            stroke: rgba(190, 255, 230, 1);
            animation: brainLinkPulse 1.35s ease-in-out infinite;
        }
        
        @keyframes brainLinkPulse {
            0% {
                opacity: 0.45;
                filter: drop-shadow(0 0 6px rgba(140, 255, 210, 0.7)) 
                        drop-shadow(0 0 16px rgba(140, 255, 210, 0.8));
            }
            50% {
                opacity: 1;
                filter: drop-shadow(0 0 12px rgba(190, 255, 230, 1)) 
                        drop-shadow(0 0 32px rgba(190, 255, 230, 1));
            }
            100% {
                opacity: 0.5;
                filter: drop-shadow(0 0 6px rgba(140, 255, 210, 0.7)) 
                        drop-shadow(0 0 16px rgba(140, 255, 210, 0.8));
            }
        }
        
        /* Brain cluster cards */
        .brain-cluster {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%) scale(1);
            min-width: 190px;
            background: rgba(12, 24, 18, 0.95);
            border: 1px solid rgba(120, 255, 190, 0.55);
            backdrop-filter: blur(10px) saturate(140%);
            color: rgba(252, 255, 254, 0.98);
            box-shadow: 0 10px 32px rgba(0,0,0,0.9),
                        0 0 18px rgba(120, 255, 190, 0.25);
            border-radius: 14px;
            padding: 10px 12px;
            pointer-events: auto;
            opacity: 0;
            transition: box-shadow .16s ease,
                        border-color .16s ease,
                        background-color .16s ease,
                        transform .16s ease,
                        opacity .18s ease;
        }
        
        .brain-cluster--active {
            background: radial-gradient(circle at 10% 0,
                rgba(30, 90, 60, 0.98) 0%,
                rgba(8, 18, 12, 0.98) 45%,
                rgba(4, 10, 8, 0.96) 100%);
            border-color: rgba(190, 255, 230, 1);
            box-shadow: 0 0 0 1px rgba(120, 255, 200, 0.9),
                        0 0 16px rgba(120, 255, 200, 1),
                        0 0 40px rgba(120, 255, 200, 0.95),
                        0 0 90px rgba(120, 255, 200, 0.9);
        }
        
        .brain-cluster h4 {
            color: #f5fff9;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(38,162,105,0.45);
            margin-bottom: 8px;
            text-align: center;
            font-size: 14px;
            letter-spacing: 0.05em;
        }
        
        .brain-chips-viewport {
            position: relative;
            overflow: hidden;
            width: 100%;
            contain: content;
            -webkit-mask-image: linear-gradient(90deg, transparent 0%, #000 10%, #000 90%, transparent 100%);
            mask-image: linear-gradient(90deg, transparent 0%, #000 10%, #000 90%, transparent 100%);
        }
        
        .brain-chips-track {
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            width: max-content;
            will-change: transform;
            transform: translate3d(0,0,0);
        }
        
        .brain-chip {
            flex: 0 0 auto;
            white-space: nowrap;
            border-radius: 6px;
            padding: 4px;
            background: rgba(38,162,105,.12);
            border: 1px solid rgba(38,162,105,.35);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
        }
        
        .brain-chip img {
            height: 20px;
            width: auto;
            border-radius: 3px;
            transition: all 0.3s ease;
        }
        
        .brain-chip:hover {
            background: rgba(38,162,105,.22);
            border-color: rgba(38,162,105,.75);
            transform: scale(1.1);
        }
        
        .brain-chip:hover img {
            filter: brightness(1.2);
        }
        
        /* Only tweak non-active cards on hover so active glow always wins */
        .brain-cluster:not(.brain-cluster--active):hover {
            border-color: rgba(120, 255, 190, 0.85);
            box-shadow: 0 0 0 1px rgba(38,162,105,0.55),
                        0 10px 28px rgba(0, 0, 0, 0.85),
                        0 0 26px rgba(38,162,105,0.65);
        }
        
        /* Let CSS beat inline opacity set by JS when hovered */
        .brain-cluster:hover { opacity: 1 !important; z-index: 9999 !important; }
        
        /* Brain name overlay */
        .brain-name2d {
            pointer-events: none;
            font: 700 clamp(18px, calc(3.6vw * var(--ui-scale)), 56px)/1.1 'Montserrat', sans-serif;
            letter-spacing: .06em;
            color: #e8fff3;
            -webkit-text-stroke: .4px rgba(0,0,0,.25);
            text-shadow: 0 0 12px rgba(38,162,105,1),
                        0 0 28px rgba(38,162,105,1),
                        0 0 48px rgba(38,162,105,.9),
                        0 0 90px rgba(38,162,105,.7);
        }
        
        /* Section styling */
        .section {
            padding: 60px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section-title {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 40px;
            color: #e8fff3;
            text-shadow: 0 0 10px rgba(38,162,105,0.7);
        }
        
        /* Mobile tweaks */
        @media (max-width: 768px) {
            #brain-host {
                height: 72svh;
            }
            
            .brain-cluster {
                background: rgba(18,24,28,.70);
            }
            
            .brain-chip {
                height: 28px;
            }
            
            .brain-chip img {
                height: 16px;
            }
        }
        /* Orbital icon styles */
        /* Cluster title only (no box) */
        .brain-cluster-title {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            opacity: 0;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        /* Title styling */
        .cluster-title {
            color: #a0ffd0;
            font-size: 64px;
            font-weight: 600;
            text-align: center;
            margin: 0;
            padding: 6px 10px;
            background: rgba(12, 24, 18, 0.3);
            border-radius: 6px;
            backdrop-filter: blur(5px);
            text-shadow: 0 0 8px rgba(120, 255, 200, 0.8);
            white-space: nowrap;
            pointer-events: none;
            border: 1px solid rgba(120, 255, 190, 0.3);
        }

        /* Orbital container - wider orbit range */
        .brain-orbit-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 140px;  /* Increased from 70px for wider orbit */
            height: 140px; /* Increased from 70px for wider orbit */
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Orbital icons */
        .orbital-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s ease;
            pointer-events: auto;
            z-index: 10;
        }

        .orbital-icon img {
            width: 96px;  /* Better aspect ratio */
            height: 96px;
            border-radius: 8px;
            transition: all 0.3s ease;
            /* Show original badge colors */
            filter: none;
            object-fit: contain;
        }

        .orbital-icon:hover img {
            transform: scale(1.8); /* Enhanced hover scale */
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.9),
                        0 0 40px rgba(160, 255, 208, 0.7),
                        0 0 80px rgba(160, 255, 208, 0.5);
            filter: brightness(1.1) contrast(1.05) saturate(1.1);
            z-index: 100;
        }

        /* Active cluster title enhancement */
        .brain-cluster-title--active .cluster-title {
            color: #e0fff0;
            text-shadow: 0 0 15px rgba(190, 255, 230, 1);
            background: rgba(30, 60, 45, 0.4);
            border-color: rgba(190, 255, 230, 0.6);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .brain-orbit-container {
                width: 120px;
                height: 120px;
            }

            .orbital-icon img {
                width: 120px;
                height: 120px;
            }

            .cluster-title {
                font-size: 100px;
                padding: 4px 8px;
            }
        }

        /* Adjust cluster card for orbital layout */
        .brain-cluster {
            min-width: 200px;
            background: rgba(12, 24, 18, 0.85);
            padding: 15px;
        }

        .cluster-title {
            text-align: center;
            margin-bottom: 15px !important;
            font-size: 28px;
            color: #a0ffd0 !important;
            text-shadow: 0 0 10px rgba(120, 255, 200, 0.7);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .brain-orbit-container {
                width: 120px;
                height: 120px;
            }
            
            .orbital-icon img {
                width: 24px;
                height: 24px;
            }
        }
    </style>
</head>
<body>
    <section id="skills" class="section">
        <h2 class="section-title">Neural Skills Network</h2>
        <div id="brain-host" class="brain-host"></div>
    </section>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/modifiers/SimplifyModifier.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <!-- Main brain visualization script -->
    <script>
        // Modified brainSkills.js to use image shields for skills
        (function() {
            'use strict';
            
            // Skill logo URLs for colorful, brand-correct icons (PNG/SVG preferred)
            // Skill logo URLs with multi-provider fallbacks (ordered by preference)
            const skillLogos = {
            Python: [
                'https://img.shields.io/badge/Python-3776AB?logo=python&logoColor=fff', // Simple Icons CDN (brand color) 
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/python.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg'
            ],

            'Neural Nets': [
                'https://img.shields.io/badge/-TensorFlow-FF6F00?logo=tensorflow&logoColor=white',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/tensorflow.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/tensorflow/tensorflow-original.svg'
            ],

            Streamlit: [
                'https://img.shields.io/badge/-Streamlit-FF4B4B?style=flat&logo=streamlit&logoColor=black',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/streamlit.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/streamlit/streamlit-original.svg'
            ],

            Plotly: [
                'https://img.shields.io/badge/-Plotly-3F4F75?style=flat&logo=plotly&logoColor=white',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/plotly.svg',
                'https://raw.githubusercontent.com/plotly/plotly.js/master/test/image/plotly-logo.png'
            ],

            MLflow: [
                'https://img.shields.io/badge/MLflow-F4AA41?logo=MLflow&logoColor=black', // slug confirmed in simple-icons slugs list 
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/mlflow.svg',
                'https://raw.githubusercontent.com/mlflow/mlflow/master/docs/theme/static/logo.png'
            ],

            Docker: [
                'https://img.shields.io/badge/Docker-2496ED?logo=docker&logoColor=fff',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/docker.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/docker/docker-original.svg'
            ],

            Kubernetes: [
                'https://img.shields.io/badge/Kubernetes-326CE5?style=for-the-badge&logo=Kubernetes&logoColor=black',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/kubernetes.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/kubernetes/kubernetes-plain.svg'
            ],

            GCP: [
                'https://img.shields.io/badge/-Google%20Cloud%20Platform-4285F4?style=flat&logo=google%20cloud&logoColor=black',
                'https://cdn.jsdelivr.net/npm/simple-icons@v15/icons/googlecloud.svg',
                'https://raw.githubusercontent.com/devicons/devicon/master/icons/googlecloud/googlecloud-original.svg'
            ],

            // Ecosystem / OSS logos not (reliably) in Simple Icons: keep project + shields.io
            LangChain: [
                'https://img.shields.io/badge/LangChain-ffffff?logo=langchain&logoColor=green',
                'https://img.shields.io/badge/LangChain-000000?logo=python&logoColor=white' // badge as a remote fallback 
            ],

            LangGraph: [
                'https://registry.npmmirror.com/@lobehub/icons-static-png/1.74.0/files/dark/langgraph-text.png',
                'https://img.shields.io/badge/LangGraph-20232A?logo=graphql&logoColor=white'
            ],

            Prompting: [
                'https://cdn.iconscout.com/icon/premium/png-256-thumb/multi-agent-icon-svg-download-png-1802462.png',
                'https://img.shields.io/badge/Prompting-412991?logo=openai&logoColor=white'
            ],

            Gradio: [
                'https://img.shields.io/badge/-Gradio-3E8EFB?style=flat&logo=gradio&logoColor=white',
                'https://img.shields.io/badge/Gradio-ff7b54?logo=python&logoColor=white'
            ],

            Dash: [
                'https://miro.medium.com/1*TFyuPnhE9tGKJ7FmJkUnDA.png',
                'https://img.shields.io/badge/Dash-119DFF?logo=plotly&logoColor=white'
            ],

            Agents: [
                'https://cdn.prod.website-files.com/65264f6bf54e751c3a776db1/68adaa7150cb5160b3708993_google-adk.png',
                'https://img.shields.io/badge/Agents-AI-blueviolet'
            ],

            'LLM Orchestration': [
                'https://cdn.iconscout.com/icon/premium/png-256-thumb/multi-agent-icon-svg-download-png-1802462.png',
                'https://img.shields.io/badge/LLM%20Orchestration-000000?logo=openai&logoColor=white'
            ],

            Eval: [
                'https://radicaldatascience.wordpress.com/wp-content/uploads/2023/06/w_and_b_logo.png',
                'https://img.shields.io/badge/Eval-FFB000?logo=huggingface&logoColor=white'
            ],

            'Seldon Core': [
                'https://i.ytimg.com/vi/VYX0v9TnLvk/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&rs=AOn4CLDxsYvMz3bD5Br93ib0Drx9a1HAXw',
                'https://img.shields.io/badge/Seldon%20Core-000000'
            ],

            Whisper: [
                'https://substackcdn.com/image/fetch/$s_!pABf!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F26ff337f-76a0-4bdc-92b4-a4d7f4cb7cde_744x388.png',
                'https://img.shields.io/badge/Whisper-000000?logo=openai&logoColor=white'
            ],

            RAG: [
                'https://writer.com/wp-content/uploads/2023/11/2023-11-Retrieval-augmented-generation-what-it-is-and-why-its-a-hot-topic-for-enterprise-AI-Blog-1.png?resize=2048,1153',
                'https://img.shields.io/badge/RAG-0b7285?logo=readthedocs&logoColor=white'
            ],

            Embeddings: [
                'https://aisera.com/wp-content/uploads/2024/03/LLM-Embeddings.png',
                'https://img.shields.io/badge/Embeddings-FFB000'
            ],

            'Vector DBs': [
                'https://images.seeklogo.com/logo-png/48/1/pinecone-logo-png_seeklogo-482364.png',
                'https://cdn.simpleicons.org/surrealdb'
            ]
            };

            // Helper to get array of URLs for a skill (ordered by priority)
            function getSkillLogoSources(skillName) {
            const sources = skillLogos[skillName];
            if (!sources || !sources.length) {
                // final remote fallback, still non-static
                return [
                `https://via.placeholder.com/96x96/ffffff/000000?text=${encodeURIComponent(
                    skillName
                )}`
                ];
            }
            return sources;
            }

            // If you only want a single URL (first provider) in existing code:
            function createSkillShield(skillName) {
            return getSkillLogoSources(skillName)[0];
            }
            
            // Main mount function
            function mountBrainSkills({
                container,
                glbPath,
                clusters = [],
                options = {}
            } = {}) {
                if (!container) throw new Error('mountBrainSkills: container is required');
                const THREE = window.THREE;
                if (!THREE?.GLTFLoader) throw new Error('THREE.GLTFLoader missing (load UMD helpers first)');

                // ---- Config ----
                const cfg = {
                    keepRatio: 0.20,
                    accent: 0x26a269,
                    baseOpacity: 0.035,
                    fresnelPow: 2.1,
                    edgeStrength: 0.10,
                    showSurface: true,
                    showEdges: true,
                    rotSpeed: 0.0009,
                    pause: false,
                    labelBaseScale: 1.0,
                    hoverScale: 1.10,
                    particles: {
                        enabled: true,
                        count: 700,
                        baseSize: 2.0,
                        pulseAmp: 2.0,
                        opacity: 0.95,
                        linksPerNode: 3,
                        linkDist: 2.8,
                        rewireMs: 700
                    },
                    name: {
                        text: '',
                        offset: { x: 0, y: -0.9, z: 0 },
                        visible: true
                    },
                    carousel: {
                        enabled: true,
                        visibleCount: 3,          // chips visible per card (desktop default)
                        switchMs: 3500,
                        switchMsMobile: 4200
                    },
                    ...options
                };

                // ---- Canvas / Renderer ----
                const canvas = document.createElement('canvas');
                canvas.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;display:block;pointer-events:auto;';
                container.style.position ||= 'relative';
                container.appendChild(canvas);

                // ---- SVG overlay for brain â†’ cluster links ----
                const linkSvgNS = 'http://www.w3.org/2000/svg';
                const linkSvg = document.createElementNS(linkSvgNS, 'svg');
                linkSvg.setAttribute('id', 'brain-links-layer');
                linkSvg.setAttribute('class', 'brain-links-svg');
                linkSvg.setAttribute('width', '100%');
                linkSvg.setAttribute('height', '100%');
                linkSvg.style.position = 'absolute';
                linkSvg.style.inset = '0';
                linkSvg.style.pointerEvents = 'none';
                container.appendChild(linkSvg);

                const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                renderer.setClearColor(0x000000, 0);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
                renderer.setSize(container.clientWidth, container.clientHeight, false);

                // ---- CSS2D overlay (name) ----
                let labelRenderer = null;
                if (THREE.CSS2DRenderer) {
                    labelRenderer = new THREE.CSS2DRenderer();
                    labelRenderer.setSize(container.clientWidth, container.clientHeight);
                    labelRenderer.domElement.style.position = 'absolute';
                    labelRenderer.domElement.style.inset = '0';
                    labelRenderer.domElement.style.pointerEvents = 'none';
                    labelRenderer.domElement.style.zIndex = '2';
                    container.appendChild(labelRenderer.domElement);
                }

                // ---- Scene / Camera / Rig ----
                const scene  = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
                camera.position.set(0, 0, 4);

                const rig = new THREE.Group(); // rotate/scale name + brain together
                scene.add(rig);

                scene.add(new THREE.AmbientLight(0xa0ffd0, 0.22));
                const dir = new THREE.DirectionalLight(0xffffff, 0.28); 
                dir.position.set(5,10,7); 
                scene.add(dir);

                // ---- Mobile / UI scale helpers ----
                let isMobile = window.matchMedia('(max-width: 768px)').matches;
                const mq = window.matchMedia('(max-width: 768px)');
                mq.addEventListener?.('change', e => { isMobile = e.matches; tuneForViewport(); });

                function computeUiScale() {
                    const w = container.clientWidth || 360;
                    const s = 0.90 + Math.min(1, Math.max(0, (w - 320) / (768 - 320))) * 0.20;
                    return s;
                }

                function getChipSwitchMs(){
                    return isMobile ? cfg.carousel.switchMsMobile : cfg.carousel.switchMs;
                }

                function tuneForViewport(){
                    const ui = computeUiScale();
                    container.style.setProperty('--ui-scale', ui.toFixed(3));
                    container.style.setProperty('--chip-font', isMobile ? '12px' : '13px');

                    cfg.carousel.visibleCount = isMobile ? 1 : (options?.carousel?.visibleCount ?? cfg.carousel.visibleCount);
                    cfg.labelBaseScale = isMobile ? 1.25 : 1.0;

                    chipCarousels.forEach(cc => { 
                        cc.visible = Math.max(1, cfg.carousel.visibleCount|0); 
                        cc.start = 0; 
                    });
                    measureAllChipCarousels();

                    resize();
                    fitBrain(isMobile ? 0.88 : 0.82);
                }

                // ---- Materials ----
                const accent = new THREE.Color(cfg.accent);
                const makeHolo = () => new THREE.ShaderMaterial({
                    uniforms: { 
                        uTime:{value:0}, 
                        uColor:{value:accent}, 
                        uFresnelPow:{value:cfg.fresnelPow}, 
                        uBaseOpacity:{value:cfg.baseOpacity} 
                    },
                    vertexShader: `
                        varying vec3 vW; varying vec3 vN;
                        void main(){ 
                            vN=normalize(normalMatrix*normal); 
                            vec4 wp=modelMatrix*vec4(position,1.0); 
                            vW=wp.xyz;
                            gl_Position=projectionMatrix*viewMatrix*wp;
                        }`,
                    fragmentShader: `
                        precision mediump float; 
                        uniform float uTime; 
                        uniform vec3 uColor; 
                        uniform float uFresnelPow; 
                        uniform float uBaseOpacity;
                        varying vec3 vW; 
                        varying vec3 vN;
                        void main(){
                            vec3 V=normalize(cameraPosition - vW);
                            float fres = pow(1.0 - max(dot(normalize(vN),V),0.0), uFresnelPow);
                            float scan = 0.5 + 0.5 * sin(vW.y*0.30 + uTime*1.2);
                            float grid = step(0.48, fract(vW.y*0.05 + uTime*0.10)) * 0.12;
                            float a = clamp(uBaseOpacity + fres*0.18 + grid, 0.0, 0.35);
                            vec3 col = uColor * (0.30 + mix(scan, 1.0, fres) * 0.45);
                            gl_FragColor = vec4(col, a);
                        }`,
                    transparent:true, 
                    depthWrite:false, 
                    blending:THREE.AdditiveBlending
                });

                const makeWire = () => new THREE.ShaderMaterial({
                    uniforms:{ 
                        uTime:{value:0}, 
                        uColor:{value:accent}, 
                        uEdge:{value:cfg.edgeStrength} 
                    },
                    vertexShader: `
                        varying vec3 vW; 
                        void main(){ 
                            vec4 wp=modelMatrix*vec4(position,1.0); 
                            vW=wp.xyz; 
                            gl_Position=projectionMatrix*viewMatrix*wp; 
                        }`,
                    fragmentShader:`
                        precision mediump float; 
                        uniform float uTime; 
                        uniform vec3 uColor; 
                        uniform float uEdge; 
                        varying vec3 vW;
                        void main(){ 
                            float w=0.5+0.5*sin(uTime*0.9+vW.y*1.0); 
                            vec3 col=uColor*(0.40+0.36*w); 
                            float a=clamp(uEdge*(0.5+0.8*w),0.,1.); 
                            gl_FragColor=vec4(col,a); 
                        }`,
                    transparent:true, 
                    depthWrite:false, 
                    blending:THREE.AdditiveBlending
                });

                // ---- Particles shaders ----
                const pointsVert = `
                    uniform float uTime; 
                    uniform float uBaseSize; 
                    uniform float uPulseAmp; 
                    uniform float uOpacity;
                    attribute float aSize; 
                    attribute float aPhase; 
                    varying float vAlpha;
                    void main(){
                        vec3 p=position; 
                        float wiggle=0.18*sin(uTime*0.8 + aPhase); 
                        p += normalize(p)*wiggle;
                        vec4 mv = modelViewMatrix*vec4(p,1.0);
                        float pulse = 0.5+0.5*sin(uTime*1.1 + aPhase);
                        float size = (uBaseSize + uPulseAmp*pulse) * aSize;
                        gl_PointSize = size * (280.0 / -mv.z);
                        vAlpha = uOpacity * (0.35 + 0.65*pulse);
                        gl_Position = projectionMatrix*mv;
                    }`;
                const pointsFrag = `
                    precision mediump float; 
                    varying float vAlpha; 
                    void main(){ 
                        vec2 c=gl_PointCoord-vec2(0.5); 
                        float d=length(c); 
                        float ring=smoothstep(0.5,0.0,d), core=smoothstep(0.18,0.0,d); 
                        float a=clamp(ring*.8 + core*.4, 0., 1.) * vAlpha; 
                        gl_FragColor=vec4(0.62,1.0,0.84,a);
                    }`;
                const lineVert = `
                    uniform float uTime; 
                    varying float vAlpha; 
                    attribute float aOpacity; 
                    attribute float aPhase; 
                    void main(){ 
                        vAlpha = aOpacity * (0.75 + 0.25 * sin(uTime*1.2 + aPhase)); 
                        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); 
                    }`;
                const lineFrag = `
                    precision mediump float; 
                    varying float vAlpha; 
                    void main(){ 
                        gl_FragColor=vec4(0.15,0.82,0.53,vAlpha); 
                    }`;

                // ---- State ----
                const loader = new THREE.GLTFLoader();
                const modifier = new THREE.SimplifyModifier();
                let root, mesh, wire, holoMat, wireMat, originalGeom;
                let animatedMats = [];
                let anchors = {};
                const cards = [];
                const hoverScale = new Map();
                let points, lines, pGeom, lineGeom, pointsMat, lineMat;
                let CONNECTIONS = cfg.particles.linksPerNode;
                let lastRewire = 0;
                let dragging=true, prevX=0, rotY=0, targetRotY=0, rafId=null;

                // ---- Per-card HORIZONTAL chip carousels ----
                const chipCarousels = [];   // [{el, viewport, track, chips, widths, offsets, start, visible, paused, gap}]
                let lastChipTick = performance.now();

                // ---- Name state ----
                let nameObj = null, nameSpriteMat = null;

                // ---- Utils ----
                const project = (obj3D) => {
                    const v = new THREE.Vector3().copy(obj3D.position);
                    obj3D.parent.localToWorld(v); 
                    v.project(camera);
                    return { 
                        x:(v.x+1)*0.5*container.clientWidth, 
                        y:(1-v.y)*0.5*container.clientHeight, 
                        z:v.z 
                    };
                };

                // HORIZONTAL chip carousel helpers
                function measureChipCarousel(cc){
                    cc.track.style.transform = 'translateX(0)';
                    cc.widths = cc.chips.map(ch => ch.getBoundingClientRect().width);
                    const vis = Math.min(cc.visible, cc.widths.length);
                    const gap = cc.gap;
                    let vpW = 0;
                    for (let i=0;i<vis;i++) vpW += cc.widths[i];
                    const gapsInView = Math.max(0, vis - 1);
                    vpW += gapsInView * gap;
                    const longest = cc.widths.slice(0, Math.max(1, vis)).reduce((a,b)=>Math.max(a,b), 0);
                    vpW = Math.max(longest, vpW);

                    cc.viewport.style.width = `${Math.ceil(vpW)}px`;

                    cc.offsets = [0];
                    for (let i = 1; i < cc.chips.length; i++) {
                        cc.offsets[i] = cc.offsets[i-1] + cc.widths[i-1] + gap;
                    }
                    applyChipWindow(cc);
                }

                function measureAllChipCarousels(){ 
                    chipCarousels.forEach(measureChipCarousel); 
                }

                function applyChipWindow(cc){
                    const x = cc.offsets[cc.start] || 0;
                    cc.track.style.transform = `translateX(-${x}px)`;
                }

                function stepChipWindow(cc){
                    if (!cc.chips.length) return;
                    cc.start = (cc.start + cc.visible) % cc.chips.length;
                    applyChipWindow(cc);
                }

                function tickChipCarousels(now){
                    if (!cfg.carousel.enabled) return;
                    const switchEvery = getChipSwitchMs();
                    if (now - lastChipTick > switchEvery) {
                        lastChipTick = now;
                        chipCarousels.forEach(cc => {
                            if (!cc.paused && cc.chips.length > cc.visible) stepChipWindow(cc);
                        });
                    }
                }

                function buildLabels() {
                    cards.forEach(c => c.el.remove());
                    cards.length = 0;
                    hoverScale.clear();

                    clusters.forEach((c, clusterIndex) => {
                        const el = document.createElement('div');
                        el.className = 'brain-cluster-title';
                        el.setAttribute('data-cluster-index', clusterIndex);

                        // Only create the title and orbit container - no box
                        el.innerHTML = `
                            <h4 class="cluster-title">${c.title || c.key}</h4>
                            <div class="brain-orbit-container"></div>
                        `;

                        container.appendChild(el);

                        // Create link line
                        const linkEl = document.createElementNS(linkSvgNS, 'line');
                        linkEl.setAttribute('class', 'brain-link');
                        linkEl.setAttribute('x1', '0');
                        linkEl.setAttribute('y1', '0');
                        linkEl.setAttribute('x2', '0');
                        linkEl.setAttribute('y2', '0');
                        linkSvg.appendChild(linkEl);

                        // Create orbital icons
                        const orbitContainer = el.querySelector('.brain-orbit-container');
                        const orbitalIcons = [];
                        
                        c.items.forEach((it, itemIndex) => {
                            const iconEl = document.createElement('div');
                            iconEl.className = 'orbital-icon';
                            iconEl.setAttribute('data-item-index', itemIndex);
                            
                            const shieldUrl = createSkillShield(it.label);
                            iconEl.innerHTML = `<img src="${shieldUrl}" alt="${it.label}" title="${it.label}">`;
                            
                            orbitContainer.appendChild(iconEl);
                            orbitalIcons.push({
                                element: iconEl,
                                label: it.label,
                                angle: (itemIndex / c.items.length) * Math.PI * 2,
                                radius: 75, // Increased from 45 for wider orbit range
                                speed: 0.3 + Math.random() * 0.4, // Slower, more elegant orbits
                                offset: Math.random() * Math.PI * 2
                            });
                        });

                        cards.push({ 
                            key: c.key, 
                            el, 
                            link: linkEl,
                            orbitalIcons,
                            clusterIndex 
                        });
                    });

                    // Start orbital animation
                    animateOrbitalIcons();
                }

                // New function to handle orbital animation
                function animateOrbitalIcons() {
                    function updateOrbits() {
                        const now = performance.now() * 0.001;
                        
                        cards.forEach(card => {
                            if (!card.orbitalIcons) return;
                            
                            card.orbitalIcons.forEach((icon, index) => {
                                // Calculate orbital position with tighter radius
                                const angle = icon.offset + now * icon.speed;
                                const x = Math.cos(angle) * icon.radius;
                                const y = Math.sin(angle) * icon.radius;
                                
                                // Apply transform
                                icon.element.style.transform = `translate(${x}px, ${y}px)`;
                                
                                // Subtle pulsing effect based on position
                                const pulse = 0.8 + 0.2 * Math.sin(now * 3 + angle);
                                icon.element.style.opacity = pulse.toString();
                                
                                // Small scale variation for depth
                                const scale = 0.9 + 0.1 * Math.cos(now * 2 + angle);
                                icon.element.children[0].style.transform = `scale(${scale})`;
                            });
                        });
                        
                        requestAnimationFrame(updateOrbits);
                    }
                    
                    updateOrbits();
                }

                function triangleCentroids(nonIndexedGeometry){
                    const pos = nonIndexedGeometry.attributes.position.array;
                    const triCount = pos.length/9, out = new Float32Array(triCount*3);
                    for(let i=0;i<triCount;i++){
                        const b=i*9;
                        out[i*3  ]=(pos[b]+pos[b+3]+pos[b+6])/3;
                        out[i*3+1]=(pos[b+1]+pos[b+4]+pos[b+7])/3;
                        out[i*3+2]=(pos[b+2]+pos[b+5]+pos[b+8])/3;
                    }
                    return out;
                }

                function buildParticlesFromGeometry(geom) {
                    if(points){ mesh.remove(points); points.geometry.dispose(); points.material.dispose(); points=null; }
                    if(lines){ mesh.remove(lines); lineGeom?.dispose?.(); lineMat?.dispose?.(); lines=null; }

                    // Create neuron-like particles along brain surface
                    const cents = triangleCentroids(geom.toNonIndexed());
                    const triCount = cents.length/3;
                    const desired = cfg.particles.count;
                    const step = Math.max(1, Math.floor(triCount/desired));
                    const count = Math.min(desired, Math.floor(triCount/step));

                    const posArr = new Float32Array(count*3);
                    const sizes  = new Float32Array(count);
                    const phases = new Float32Array(count);
                    const types  = new Float32Array(count); // 0=soma, 1=axon, 2=dendrite
                    
                    for(let i=0,j=0;i<triCount && j<count;i+=step,j++){
                        posArr[j*3]=cents[i*3]; 
                        posArr[j*3+1]=cents[i*3+1]; 
                        posArr[j*3+2]=cents[i*3+2];
                        sizes[j]=0.8+Math.random()*0.6; // Vary neuron sizes
                        phases[j]=Math.random()*Math.PI*2;
                        types[j]=Math.floor(Math.random()*3); // Random neuron type
                    }

                    pGeom = new THREE.BufferGeometry();
                    pGeom.setAttribute('position', new THREE.BufferAttribute(posArr,3));
                    pGeom.setAttribute('aSize', new THREE.BufferAttribute(sizes,1));
                    pGeom.setAttribute('aPhase', new THREE.BufferAttribute(phases,1));
                    pGeom.setAttribute('aType', new THREE.BufferAttribute(types,1));
                    
                    // Enhanced neuron shader material
                    // Single color neuron shader material
                    pointsMat = new THREE.ShaderMaterial({
                        uniforms:{
                            uTime:{value:0}, 
                            uBaseSize:{value:cfg.particles.baseSize}, 
                            uPulseAmp:{value:cfg.particles.pulseAmp}, 
                            uOpacity:{value:cfg.particles.opacity} 
                        },
                        vertexShader: `
                            uniform float uTime;
                            uniform float uBaseSize;
                            uniform float uPulseAmp;
                            uniform float uOpacity;
                            attribute float aSize;
                            attribute float aPhase;
                            varying float vAlpha;
                            
                            void main(){
                                vec3 p = position;
                                
                                // Neural pulse behavior
                                float neuralPulse = 0.5 + 0.5 * sin(uTime*1.2 + aPhase + position.y*2.0);
                                
                                // Subtle neuron movement
                                float drift = 0.015 * sin(uTime*0.4 + aPhase*3.0);
                                p += normal * drift;
                                
                                vec4 mv = modelViewMatrix * vec4(p, 1.0);
                                float size = (uBaseSize + uPulseAmp * neuralPulse) * aSize;
                                gl_PointSize = size * (280.0 / -mv.z);
                                vAlpha = uOpacity * (0.5 + 0.5 * neuralPulse);
                                gl_Position = projectionMatrix * mv;
                            }`,
                        fragmentShader: `
                            precision mediump float;
                            varying float vAlpha;
                            
                            void main(){
                                vec2 coord = gl_PointCoord - vec2(0.5);
                                float dist = length(coord);
                                
                                // Single neural color (electric blue-white)
                                vec3 color = vec3(0.6, 0.9, 1.0);
                                
                                // Neuron shape with bright core and soft halo
                                float core = smoothstep(0.4, 0.0, dist) * 1.0;
                                float halo = smoothstep(0.5, 0.3, dist) * 0.6;
                                float a = (core + halo) * vAlpha;
                                
                                gl_FragColor = vec4(color, a);
                            }`,
                        transparent:true, 
                        depthWrite:false, 
                        blending:THREE.AdditiveBlending
                    });

                    // Single color neural connections
                    lineMat = new THREE.ShaderMaterial({ 
                        uniforms:{
                            uTime:{value:0},
                            uPulseSpeed:{value:1.5}
                        }, 
                        vertexShader: `
                            uniform float uTime;
                            uniform float uPulseSpeed;
                            attribute float aOpacity;
                            attribute float aPhase;
                            varying float vAlpha;
                            
                            void main(){
                                // Neural impulse traveling
                                float impulse = sin(uTime * uPulseSpeed + aPhase + position.x * 2.0);
                                vAlpha = aOpacity * (0.4 + 0.6 * impulse * impulse);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }`,
                        fragmentShader: `
                            precision mediump float;
                            varying float vAlpha;
                            
                            void main(){
                                // Single color for neural connections
                                vec3 color = vec3(0.4, 0.8, 1.0);
                                gl_FragColor = vec4(color, vAlpha);
                            }`,
                        transparent:true, 
                        depthWrite:false, 
                        blending:THREE.AdditiveBlending 
                    });
                    
                    points = new THREE.Points(pGeom, pointsMat); 
                    points.visible = cfg.particles.enabled;
                    mesh.add(points);

                    // Neural connections (axon-dendrite links)
                    CONNECTIONS = cfg.particles.linksPerNode;
                    const maxSeg = count * CONNECTIONS;
                    const linePositions = new Float32Array(maxSeg*2*3);
                    const lineOpacities = new Float32Array(maxSeg*2);
                    const linePhases    = new Float32Array(maxSeg*2);
                    
                    lineGeom = new THREE.BufferGeometry();
                    lineGeom.setAttribute('position', new THREE.BufferAttribute(linePositions,3).setUsage(THREE.DynamicDrawUsage));
                    lineGeom.setAttribute('aOpacity', new THREE.BufferAttribute(lineOpacities,1).setUsage(THREE.DynamicDrawUsage));
                    lineGeom.setAttribute('aPhase',   new THREE.BufferAttribute(linePhases,1).setUsage(THREE.DynamicDrawUsage));
                    
                    // Enhanced neural connection shader
                    lineMat = new THREE.ShaderMaterial({ 
                        uniforms:{
                            uTime:{value:0},
                            uPulseSpeed:{value:2.0}
                        }, 
                        vertexShader: `
                            uniform float uTime;
                            uniform float uPulseSpeed;
                            attribute float aOpacity;
                            attribute float aPhase;
                            varying float vAlpha;
                            
                            void main(){
                                // Neural impulse traveling along connections
                                float impulse = sin(uTime * uPulseSpeed + aPhase + position.x * 3.0);
                                vAlpha = aOpacity * (0.3 + 0.7 * impulse * impulse);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }`,
                        fragmentShader: `
                            precision mediump float;
                            varying float vAlpha;
                            
                            void main(){
                                // Neural connection color (axonal fibers)
                                vec3 color = vec3(0.4, 0.9, 0.7);
                                gl_FragColor = vec4(color, vAlpha);
                            }`,
                        transparent:true, 
                        depthWrite:false, 
                        blending:THREE.AdditiveBlending 
                    });
                    
                    lines = new THREE.LineSegments(lineGeom, lineMat); 
                    lines.visible = cfg.particles.enabled && CONNECTIONS>0;
                    mesh.add(lines);

                    // Create neural connections
                    const LINK2 = cfg.particles.linkDist * cfg.particles.linkDist;
                    const pa = pGeom.attributes.position.array; 
                    const typesArr = pGeom.attributes.aType.array;
                    const n = pa.length/3;
                    const maxPer = new Uint8Array(n); 
                    let countSeg=0;
                    
                    for(let i=0;i<n;i++){
                        if(maxPer[i]>=CONNECTIONS) continue;
                        const ax=pa[i*3], ay=pa[i*3+1], az=pa[i*3+2];
                        
                        for(let j=i+1;j<n;j++){
                            if(maxPer[j]>=CONNECTIONS) continue;
                            const bx=pa[j*3], by=pa[j*3+1], bz=pa[j*3+2];
                            const dx=ax-bx, dy=ay-by, dz=az-bz; 
                            const d2=dx*dx+dy*dy+dz*dz;
                            
                            if(d2 < LINK2){
                                const k=countSeg*2*3; 
                                if(k>=linePositions.length) break;
                                linePositions[k]=ax; linePositions[k+1]=ay; linePositions[k+2]=az;
                                linePositions[k+3]=bx; linePositions[k+4]=by; linePositions[k+5]=bz;
                                
                                const baseOp = Math.max(0.08, 1.0 - Math.sqrt(d2)/cfg.particles.linkDist) * 0.4;
                                const o=countSeg*2; 
                                lineOpacities[o]=baseOp; lineOpacities[o+1]=baseOp;
                                const p=countSeg*2; 
                                linePhases[p]=Math.random()*Math.PI*2; linePhases[p+1]=Math.random()*Math.PI*2;
                                
                                countSeg++; 
                                maxPer[i]++; maxPer[j]++; 
                                if(maxPer[i]>=CONNECTIONS) break;
                            }
                        }
                    }
                    
                    lineGeom.setDrawRange(0, countSeg*2);
                    lineGeom.attributes.position.needsUpdate = true;
                    lineGeom.attributes.aOpacity.needsUpdate = true;
                    lineGeom.attributes.aPhase.needsUpdate = true;
                }

                function buildWithRatio(keep){
                    let geom = THREE.BufferGeometryUtils.mergeVertices(mesh.geometry.toNonIndexed());
                    const triCount = geom.attributes.position.count/3;
                    const target = Math.max(48, Math.floor(triCount*keep));
                    geom = modifier.modify(geom, target);
                    geom.computeVertexNormals();
                    mesh.geometry = geom;

                    holoMat = makeHolo();
                    mesh.material = holoMat;

                    if(wire) mesh.remove(wire);
                    wireMat = makeWire();
                    wire = new THREE.LineSegments(new THREE.WireframeGeometry(geom), wireMat);
                    mesh.add(wire);

                    animatedMats = [];
                    mesh.traverse(o => { 
                        const m=o.material; 
                        if(m?.uniforms?.uTime) animatedMats.push(m); 
                    });
                }

                // ---- Name text sprite fallback ----
                function makeTextSprite(text){
                    const cnv = document.createElement('canvas');
                    const ctx = cnv.getContext('2d');
                    const px = 256, pad = 32;
                    cnv.width = 1024; 
                    cnv.height = 256;
                    ctx.font = `700 ${px}px Montserrat, sans-serif`;
                    const m = ctx.measureText(text);
                    cnv.width = Math.ceil(m.width) + pad*2;
                    cnv.height = px + pad*2;
                    ctx.font = `700 ${px}px Montserrat, sans-serif`;
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#e8fff3';
                    ctx.shadowColor = 'rgba(38,162,105,1)';
                    ctx.shadowBlur = 48;
                    ctx.fillText(text, cnv.width/2, cnv.height/2);
                    const tex = new THREE.CanvasTexture(cnv);
                    tex.minFilter = THREE.LinearFilter;
                    nameSpriteMat = new THREE.SpriteMaterial({ 
                        map: tex, 
                        transparent: true, 
                        depthWrite: false, 
                        depthTest: false 
                    });
                    const sprite = new THREE.Sprite(nameSpriteMat);
                    const wUnits = 2.0;
                    const aspect = cnv.width / cnv.height;
                    sprite.scale.set(wUnits, wUnits/aspect, 1);
                    sprite.renderOrder = 9999;
                    return sprite;
                }

                // ---- Resize / Animate ----
                function resize(){
                    const rect = container.getBoundingClientRect();
                    const w = Math.max(1, Math.floor(rect.width));
                    const h = Math.max(1, Math.floor(rect.height));

                    const dpr = Math.min(window.devicePixelRatio || 1, 2);
                    renderer.setPixelRatio(dpr);
                    renderer.setSize(w, h, false);

                    camera.aspect = w / h; 
                    camera.updateProjectionMatrix();
                    if (labelRenderer) labelRenderer.setSize(w, h);
                }

                function animate() {
                    rafId = requestAnimationFrame(animate);
                    if (!root) return;

                    if (!cfg.pause && !dragging) targetRotY += cfg.rotSpeed;
                    rotY += (targetRotY - rotY) * 0.08;
                    rig.rotation.y = rotY;

                    const t = performance.now() * 0.001;
                    const now = performance.now();

                    // per-card chip carousels
                    tickChipCarousels(now);

                    animatedMats.forEach(m => m.uniforms.uTime.value = t);
                    if (pointsMat) { pointsMat.uniforms.uTime.value = t; }
                    if (lineMat) { lineMat.uniforms.uTime.value = t; }

                    if (lines && now - lastRewire > cfg.particles.rewireMs) {
                        lastRewire = now;
                        buildParticlesFromGeometry(mesh.geometry);
                    }

                    // viewport + UI scale
                    const rect = container.getBoundingClientRect();
                    const cx = rect.width * 0.5;
                    const cy = rect.height * 0.5;
                    const ui = parseFloat(getComputedStyle(container).getPropertyValue('--ui-scale')) || 1;

                    // 1) Collect card state (so we can find the closest one)
                    const cardState = [];
                    cards.forEach(({ key, el, link }) => {
                        const anchor = anchors[key];
                        if (!anchor) return;

                        const s = project(anchor.node);
                        const depth = 1 - Math.min(1, Math.max(0, s.z)); // 0 = far, 1 = close

                        const dx = s.x - cx;
                        const dy = s.y - cy;
                        const len = Math.hypot(dx, dy) || 1;

                        cardState.push({ el, link, anchor, s, depth, dx, dy, len });
                    });

                    // 2) Choose the single "front" card by max depth
                    let active = null;
                    if (cardState.length) {
                        active = cardState.reduce((best, cur) =>
                            !best || cur.depth > best.depth ? cur : best,
                            null
                        );
                    }

                    // 3) Position titles + links, highlight active
                    cardState.forEach(st => {
                        const { el, link, s, depth, dx, dy, len } = st;

                        // Reduced radial positioning - bring clusters closer to brain
                        const push = 80 * ui; // Reduced from 120 to 80
                        const titleX = s.x + (dx / len) * push;
                        const titleY = s.y + (dy / len) * push;

                        // Base scaling - slightly reduced
                        let baseScale = cfg.labelBaseScale * (0.8 + depth * 0.4);
                        let finalScale = baseScale * ui;

                        // Opacity
                        let opac = (s.z < 1.0) ? (0.6 + depth * 0.4) : 0.4;

                        const isActive = active && active.el === el && depth > 0.25;

                        if (isActive) {
                            el.classList.add('brain-cluster-title--active');
                            finalScale *= 1.15; // Reduced boost
                            opac = Math.max(opac, 0.9);
                        } else {
                            el.classList.remove('brain-cluster-title--active');
                        }

                        // Apply transform to title element
                        el.style.transform = `translate(${titleX}px, ${titleY}px) translate(-50%,-50%) scale(${finalScale})`;
                        el.style.opacity = opac.toFixed(3);
                        el.style.zIndex = String(500 + Math.round(depth * 500));

                        // Link from brain to title center - shorter
                        if (link) {
                            const innerX = s.x + (dx / len) * 10; // Reduced from 12
                            const innerY = s.y + (dy / len) * 10;

                            link.setAttribute('x1', innerX.toFixed(1));
                            link.setAttribute('y1', innerY.toFixed(1));
                            link.setAttribute('x2', titleX.toFixed(1));
                            link.setAttribute('y2', titleY.toFixed(1));

                            const linkOpacity = isActive ? 0.8 : (0.3 + depth * 0.3);
                            link.style.opacity = linkOpacity.toFixed(3);

                            if (isActive) {
                                link.classList.add('brain-link--active');
                            } else {
                                link.classList.remove('brain-link--active');
                            }
                        }
                    });

                    // 4) Pulse inner cluster "keys" inside the brain (small neon spheres)
                    const pulse = 0.5 + 0.5 * Math.sin(t * 2.1);
                    Object.values(anchors).forEach(({ glow }) => {
                        if (!glow) return;

                        const baseScale = 0.7;
                        const pulseScale = 0.35;
                        const sVal = baseScale + pulse * pulseScale;

                        glow.scale.setScalar(sVal);
                        const mat = glow.material;
                        if (mat) {
                            mat.opacity = 0.35 + 0.45 * pulse;
                        }
                    });

                    if (wire) wire.visible = cfg.showEdges && cfg.edgeStrength > 0.001;
                    if (mesh) mesh.material.visible = cfg.showSurface;
                    if (points) points.visible = cfg.particles.enabled;
                    if (lines)  lines.visible  = cfg.particles.enabled && cfg.particles.linksPerNode > 0;

                    renderer.render(scene, camera);
                    if (labelRenderer) labelRenderer.render(scene, camera);
                }

                function fitBrain(fill = 0.85) {
                    if (!root) return;
                    rig.scale.setScalar(1);
                    const fov = THREE.Math.degToRad(camera.fov);
                    const viewH = 2 * Math.tan(fov / 2) * camera.position.z;
                    const viewW = viewH * camera.aspect;
                    const box = new THREE.Box3().setFromObject(root);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const sx = (viewW  * fill) / (size.x || 1);
                    const sy = (viewH  * fill) / (size.y || 1);
                    const s  = Math.min(sx, sy);
                    rig.scale.setScalar(s);
                }

                // ---- Load GLB ----
                loader.load(glbPath, (gltf)=>{
                    root = gltf.scene;
                    mesh = null; 
                    root.traverse(o=>{ if(o.isMesh && !mesh) mesh=o; });
                    if(!mesh) throw new Error('No mesh in GLB');

                    originalGeom = THREE.BufferGeometryUtils.mergeVertices(mesh.geometry.toNonIndexed());
                    mesh.geometry = originalGeom.clone();
                    buildWithRatio(cfg.keepRatio);

                    const box = new THREE.Box3().setFromObject(root);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const center = new THREE.Vector3(); box.getCenter(center);
                    root.position.sub(center);

                    // anchors
                    const extX = size.x/2, extY=size.y/2, extZ=size.z/2;
                    const anchorVecs = {
                        frontal:    new THREE.Vector3(0,         0.10*extY, +0.62*extZ),
                        visual:     new THREE.Vector3(0,         0.10*extY, -0.62*extZ),
                        motor:      new THREE.Vector3(0,         0.65*extY,  0),
                        temporalL:  new THREE.Vector3(-0.68*extX, 0.00,     0.12*extZ),
                        temporalR:  new THREE.Vector3( 0.68*extX, 0.00,     0.12*extZ),
                        infra:      new THREE.Vector3(0,        -0.62*extY, -0.20*extZ),
                    };
                    anchors = {};

                    // Smaller glow radius
                    const brainDiag = size.length(); // diagonal of the brain bounding box
                    const glowRadius = brainDiag * 0.008; // was effectively ~0.02 before

                    const glowGeo = new THREE.SphereGeometry(glowRadius, 16, 16);
                    const glowMatBase = new THREE.MeshBasicMaterial({
                        color: accent,
                        transparent: true,
                        opacity: 0.9,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });

                    Object.entries(anchorVecs).forEach(([k, v]) => {
                        const node = new THREE.Object3D();
                        node.position.copy(v);
                        mesh.add(node);

                        // Small neon "key" inside the brain
                        const glow = new THREE.Mesh(glowGeo, glowMatBase.clone());
                        glow.scale.setScalar(0.9);
                        node.add(glow);

                        anchors[k] = { node, glow };
                    });

                    buildLabels();
                    document.querySelectorAll('.brain-chips-track').forEach(t=>{
                        const w = t.getBoundingClientRect().width;
                        t.style.setProperty('--track-w', `${w + 1 + 6}px`); // +1 to avoid subpixel seam; +gap
                    });
                    buildParticlesFromGeometry(mesh.geometry);
                    rig.add(root);

                    // name
                    if (labelRenderer && THREE.CSS2DObject) {
                        const nameEl = document.createElement('div');
                        nameEl.className = 'brain-name2d';
                        nameEl.textContent = cfg.name.text;
                        nameObj = new THREE.CSS2DObject(nameEl);
                    } else {
                        nameObj = makeTextSprite(cfg.name.text);
                    }
                    nameObj.position.set(cfg.name.offset.x, cfg.name.offset.y, cfg.name.offset.z);
                    nameObj.visible = !!cfg.name.visible;
                    rig.add(nameObj);

                    // input - desktop mouse controls
                    canvas.addEventListener('mousedown', e=>{ dragging=true; prevX=e.clientX; });
                    window.addEventListener('mousemove', e=>{ if(!dragging) return; targetRotY += (e.clientX-prevX)*0.003; prevX=e.clientX; });
                    window.addEventListener('mouseup', ()=> dragging=false);

                    // mobile touch controls
                    let touchDragging = false;
                    let lastTouchX = 0;
                    let lastTouchY = 0;
                    let initialPinchDistance = 0;
                    let initialCameraDistance = 4;
                    let minZoom = 2;
                    let maxZoom = 8;
                    let touchPointers = new Map();

                    function getTouchDistance(touches) {
                        if (touches.length < 2) return 0;
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        return Math.sqrt(dx * dx + dy * dy);
                    }

                    canvas.addEventListener('touchstart', e => {
                        e.preventDefault();
                        const touches = e.touches;
                        for (let i = 0; i < touches.length; i++) {
                            touchPointers.set(touches[i].identifier, {
                                x: touches[i].clientX,
                                y: touches[i].clientY
                            });
                        }
                        if (touches.length === 1) {
                            touchDragging = true;
                            lastTouchX = touches[0].clientX;
                            lastTouchY = touches[0].clientY;
                        } else if (touches.length === 2) {
                            touchDragging = false;
                            initialPinchDistance = getTouchDistance(touches);
                            initialCameraDistance = camera.position.z;
                        }
                    }, { passive: false });

                    canvas.addEventListener('touchmove', e => {
                        e.preventDefault();
                        const touches = e.touches;
                        if (touches.length === 1 && touchDragging) {
                            const touch = touches[0];
                            const deltaX = touch.clientX - lastTouchX;
                            targetRotY += deltaX * 0.003;
                            lastTouchX = touch.clientX;
                            lastTouchY = touch.clientY;
                        } else if (touches.length === 2) {
                            const currentDistance = getTouchDistance(touches);
                            if (initialPinchDistance > 0) {
                                const scale = currentDistance / initialPinchDistance;
                                let newDistance = initialCameraDistance / scale;
                                newDistance = Math.max(minZoom, Math.min(maxZoom, newDistance));
                                camera.position.z = newDistance;
                                camera.updateProjectionMatrix();
                            }
                        }
                    }, { passive: false });

                    canvas.addEventListener('touchend', e => {
                        e.preventDefault();
                        const touches = e.changedTouches;
                        for (let i = 0; i < touches.length; i++) {
                            touchPointers.delete(touches[i].identifier);
                        }
                        if (e.touches.length === 0) {
                            touchDragging = false;
                            initialPinchDistance = 0;
                        } else if (e.touches.length === 1) {
                            touchDragging = true;
                            lastTouchX = e.touches[0].clientX;
                            lastTouchY = e.touches[0].clientY;
                        }
                    }, { passive: false });

                    tuneForViewport();
                    animate();
                });

                // ---- Resize observer ----
                const ro = new ResizeObserver(() => {
                    resize();
                    fitBrain(isMobile ? 0.88 : 0.82);
                    if (labelRenderer) labelRenderer.setSize(renderer.domElement.width, renderer.domElement.height);
                    measureAllChipCarousels();
                });
                ro.observe(container);

                // ---- API ----
                return {
                    setOptions(next){
                        Object.assign(cfg, next||{});
                        if(next?.particles){
                            Object.assign(cfg.particles, next.particles);
                            if(pointsMat){
                                pointsMat.uniforms.uBaseSize.value = cfg.particles.baseSize;
                                pointsMat.uniforms.uPulseAmp.value = cfg.particles.pulseAmp;
                                pointsMat.uniforms.uOpacity.value  = cfg.particles.opacity;
                            }
                            buildParticlesFromGeometry(mesh.geometry);
                        }
                        if(holoMat){
                            holoMat.uniforms.uBaseOpacity.value = cfg.baseOpacity;
                            holoMat.uniforms.uFresnelPow.value  = cfg.fresnelPow;
                        }
                        if(wireMat){ wireMat.uniforms.uEdge.value = cfg.edgeStrength; }
                        if(next?.name && nameObj){
                            if (typeof next.name.text === 'string') {
                                if (nameObj.isCSS2DObject) {
                                    nameObj.element.textContent = next.name.text;
                                } else if (nameSpriteMat) {
                                    rig.remove(nameObj);
                                    nameObj = makeTextSprite(next.name.text);
                                    nameObj.position.set(cfg.name.offset.x, cfg.name.offset.y, cfg.name.offset.z);
                                    rig.add(nameObj);
                                }
                                cfg.name.text = next.name.text;
                            }
                            if (next.name.offset){
                                cfg.name.offset = { ...cfg.name.offset, ...next.name.offset };
                                nameObj.position.set(cfg.name.offset.x, cfg.name.offset.y, cfg.name.offset.z);
                            }
                            if (typeof next.name.visible === 'boolean'){
                                cfg.name.visible = next.name.visible;
                                nameObj.visible = cfg.name.visible;
                            }
                        }
                        if(next?.carousel){
                            Object.assign(cfg.carousel, next.carousel);
                            chipCarousels.forEach(cc => { 
                                cc.visible = Math.max(1, cfg.carousel.visibleCount|0); 
                                cc.start = 0; 
                            });
                            lastChipTick = performance.now();
                            measureAllChipCarousels();
                        }
                        // retune view if options affect layout
                        tuneForViewport();
                    },
                    destroy(){
                        cancelAnimationFrame(rafId);
                        ro.disconnect();
                        window.removeEventListener('mouseup', ()=>{});
                        window.removeEventListener('mousemove', ()=>{});
                        renderer.dispose();
                        if (labelRenderer) {
                            labelRenderer.dispose?.();
                            labelRenderer.domElement.remove();
                        }
                        canvas.remove();
                        cards.forEach(c=>c.el.remove());
                    }
                };
            }

            // Make the function available globally
            window.mountBrainSkills = mountBrainSkills;
        })();
    </script>

    <!-- Initialize the brain visualization -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const host = document.getElementById('brain-host');
            
            // Define clusters with skills
            const clusters = [
                { 
                    key: 'frontal',   
                    title: 'Reasoning Â· Planning', 
                    items: [
                        {label: 'Python'}, 
                        {label: 'LangGraph'}, 
                        {label: 'Neural Nets'}, 
                        {label: 'LangChain'}
                    ]
                },
                { 
                    key: 'visual',    
                    title: 'Visual Cortex',        
                    items: [
                        {label: 'Streamlit'}, 
                        {label: 'Gradio'}, 
                        {label: 'Plotly'}, 
                        {label: 'Dash'}
                    ]
                },
                { 
                    key: 'motor',     
                    title: 'Motor Â· Control',      
                    items: [
                        {label: 'Agents'}, 
                        {label: 'LLM Orchestration'}, 
                        {label: 'Eval'}, 
                        {label: 'MLflow'}, 
                        {label: 'Seldon Core'}
                    ]
                },
                { 
                    key: 'temporalR', 
                    title: 'Temporal Â· R',         
                    items: [
                        {label: 'Whisper'}
                    ]
                },
                { 
                    key: 'temporalL', 
                    title: 'Temporal Â· L',         
                    items: [
                        {label: 'RAG'}, 
                        {label: 'Embeddings'}, 
                        {label: 'Vector DBs'}
                    ]
                },
                { 
                    key: 'infra',     
                    title: 'Infrastructure',       
                    items: [
                        {label: 'Docker'}, 
                        {label: 'Kubernetes'}, 
                        {label: 'GCP'}
                    ]
                }
            ];

            // Mount the brain visualization
            const brain = mountBrainSkills({
                container: host,
                glbPath: './brain.glb', // Make sure this file is available
                clusters,
                options: {
                    baseOpacity: 0.03,
                    edgeStrength: 0.10,
                    hoverScale: 1.12,
                    labelBaseScale: 1.05,
                    particles: {
                        enabled: true,
                        count: 300, // Further reduced for cleaner look
                        baseSize: 0.05, // Much smaller neurons
                        pulseAmp: 0.15, // Reduced pulse amplitude
                        opacity: 0.7,
                        linksPerNode: 2,
                        linkDist: 2.8, // Slightly reduced connection distance
                        rewireMs: 2500 // Slower rewiring
                    },
                    carousel: { 
                        visibleCount: 3, 
                        switchMs: 3500, 
                        switchMsMobile: 4200 
                    }
                }
            });

            // Adjust for mobile if needed
            if (window.matchMedia('(max-width: 768px)').matches) {
                brain.setOptions({
                    particles: { 
                        count: 5, 
                        baseSize: 0.2, 
                        linksPerNode: 2, 
                        linkDist: 2.4, 
                        rewireMs: 1100 
                    }
                });
            }
        });
    </script>
</body>
</html>
