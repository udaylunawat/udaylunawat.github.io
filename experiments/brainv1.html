<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Brain GLB â€” Hologram + Pulsing Edges (80% Simplified)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Three + UMD example helpers (versions matched) -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/modifiers/SimplifyModifier.js"></script>
  <style>
    html, body { height:100%; margin:0; background:#0f1318; }
    #stage { width:100%; height:100%; display:block; }
  </style>
</head>
<body>
<canvas id="stage"></canvas>

<script>
  // ---------- Basic setup ----------
  const canvas   = document.getElementById('stage');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene  = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0f1318, 40, 120);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.set(0, 0, 4);

  scene.add(new THREE.AmbientLight(0xa0ffd0, 0.35));
  const dir = new THREE.DirectionalLight(0xffffff, 0.4);
  dir.position.set(5, 10, 7);
  scene.add(dir);

  const loader   = new THREE.GLTFLoader();
  const modifier = new THREE.SimplifyModifier();

  const KEEP_RATIO = 0.20;              // keep 20% of triangles (~80% reduction)
  const ACCENT     = 0x26a269;          // brand green

  // ---------- Hologram surface shader ----------
  function makeHologramMaterial(colorHex) {
    return new THREE.ShaderMaterial({
      uniforms: {
        uTime:        { value: 0 },
        uColor:       { value: new THREE.Color(colorHex) },
        uFresnelPow:  { value: 1.8 },
        uBaseOpacity: { value: 0.18 },
      },
      vertexShader: `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPos = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision mediump float;
        uniform float uTime;
        uniform vec3  uColor;
        uniform float uFresnelPow;
        uniform float uBaseOpacity;
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        void main() {
          // Fresnel edge highlight
          vec3  V = normalize(cameraPosition - vWorldPos);
          float fres = pow(1.0 - max(dot(normalize(vNormal), V), 0.0), uFresnelPow);

          // Vertical scan + subtle grid drift
          float scan = 0.5 + 0.5 * sin(vWorldPos.y * 0.35 + uTime * 2.2);
          float grid = step(0.48, fract(vWorldPos.y * 0.08 + uTime * 0.2)) * 0.25;

          float alpha = clamp(uBaseOpacity + fres * 0.35 + grid, 0.0, 1.0);
          vec3  col   = uColor * (0.45 + mix(scan, 1.0, fres) * 0.75);
          gl_FragColor = vec4(col, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
  }

  // ---------- Pulsing wireframe line shader ----------
  function makeWirePulseMaterial(colorHex) {
    return new THREE.ShaderMaterial({
      uniforms: {
        uTime:  { value: 0 },
        uColor: { value: new THREE.Color(colorHex) }
      },
      vertexShader: `
        varying vec3 vWorldPos;
        void main() {
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPos = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision mediump float;
        uniform float uTime;
        uniform vec3  uColor;
        varying vec3  vWorldPos;
        void main() {
          // Edge pulse moves upward in Y and over time
          float wave = 0.6 + 0.4 * sin(uTime * 1.8 + vWorldPos.y * 1.2);
          vec3  col  = uColor * (0.7 + 0.6 * wave);
          float a    = 0.25 + 0.55 * wave; // opacity pulse
          gl_FragColor = vec4(col, a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
  }

  // ---------- Load, simplify, and build materials ----------
  loader.load(
    './brain.glb',
    (gltf) => {
      let wireOverlay = null;

      gltf.scene.traverse((o) => {
        if (!o.isMesh || !o.geometry || !o.geometry.isBufferGeometry) return;

        // Work on a non-indexed, merged-vertices copy for better simplification
        let geom = o.geometry.toNonIndexed();
        if (THREE.BufferGeometryUtils && THREE.BufferGeometryUtils.mergeVertices) {
          geom = THREE.BufferGeometryUtils.mergeVertices(geom);
        }

        const triCount = geom.attributes.position.count / 3;
        const target   = Math.max(12, Math.floor(triCount * KEEP_RATIO)); // never collapse to nothing

        geom = modifier.modify(geom, target);
        geom.computeVertexNormals();

        // Apply hologram shader to surface
        o.geometry = geom;
        o.material = makeHologramMaterial(ACCENT);

        // Build a separate pulsing wireframe overlay (from simplified geometry)
        const wfGeom = new THREE.WireframeGeometry(geom);
        const wfMat  = makeWirePulseMaterial(ACCENT);
        wireOverlay  = new THREE.LineSegments(wfGeom, wfMat);
        wireOverlay.renderOrder = 1; // draw after surface
        o.add(wireOverlay);          // attach to the same transform
      });

      // Center + scale for view
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      gltf.scene.position.sub(center);
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      gltf.scene.scale.setScalar(3.0 / maxDim);

      scene.add(gltf.scene);

      // Keep references to animate shader time
      const materials = [];
      gltf.scene.traverse((o) => {
        if (o.material && o.material.uniforms && o.material.uniforms.uTime) {
          materials.push(o.material);
        }
        if (o.isLineSegments && o.material && o.material.uniforms && o.material.uniforms.uTime) {
          materials.push(o.material);
        }
      });

      // Animate
      (function animate(){
        requestAnimationFrame(animate);
        scene.rotation.y += 0.003;

        const t = performance.now() * 0.0016;
        for (const m of materials) m.uniforms.uTime.value = t;

        renderer.render(scene, camera);
      })();
    },
    undefined,
    (err) => console.error('Failed to load brain.glb:', err)
  );

  // ---------- Resize ----------
  window.addEventListener('resize', () => {
    const w = window.innerWidth, h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>